CCS PCM C Compiler, Version 4.104, 5967               16-set-17 07:31

               Filename: C:\DADOS\projeto\MicrochipPicTeclado_4x4\main.lst

               ROM used: 207 words (3%)
                         Largest free fragment is 2048
               RAM used: 13 (4%) at main() level
                         14 (4%) worst case
               Stack:    2 worst case (1 in main + 1 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   097
0003:  NOP
.................... //**************************************************************************** 
.................... //                      EXEMPLO COM TECLADO 4X4 
.................... //**************************************************************************** 
.................... //Compilador CCS PCWH Ver 4.104 
....................  
.................... #include <16F877.h>              //include do 16F628 
.................... //////// Standard Header file for the PIC16F877 device //////////////// 
.................... #device PIC16F877 
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
00A2:  BCF    03.5
00A3:  CLRF   20
00A4:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <16f8x_registradores.h>//MAPEAMENTO DE MEÓRIA DOS REGISTRADORES 
.................... //********************************************************** 
.................... //INCLUDE DE MAPEAMENTO DE MEÓRIA DOS REGISTRADORES 
.................... //ESPECIAIS E BITS DOS MESMOS PARA OS mC 16f87X 
.................... //********************************************************** 
....................  
.................... #byte option_reg = 0x81 
.................... #byte status = 0x03 
.................... #byte tris_a = 0x85        //#byte - define o endereco do 
.................... #byte tris_b = 0x86        //registrador no banco de memoria 
.................... #byte tris_c = 0x87        //de acordo com o datasheet 
.................... #byte tris_d = 0x88        //de acordo com o datasheet 
.................... #byte tris_e = 0x89        //de acordo com o datasheet 
.................... #byte port_a = 0x05 
.................... #byte port_b = 0x06 
.................... #byte port_c = 0x07 
.................... #byte port_d = 0x08 
.................... #byte port_e = 0x09 
.................... #byte intcon = 0x0b 
....................  
.................... //USART 
.................... #byte txsta = 0x98 
.................... #byte rcsta = 0x18 
.................... #byte spbrg = 0x99 
.................... #byte txreg = 0x19 
.................... #byte rcreg = 0x1a    
....................  
.................... #byte pir1 = 0x0c 
.................... #byte pie1 = 0x8c 
....................  
.................... //registrador pie1 
.................... #bit  eeie   = pie1.7 
.................... #bit  cmie   = pie1.6 
.................... #bit  rcie   = pie1.5 
.................... #bit  txie   = pie1.4 
.................... #bit  ccp1ie = pie1.2 
.................... #bit  tmr2ie = pie1.1 
.................... #bit  tmr1ie = pie1.0 
....................  
.................... //registrador pir1 
.................... #bit  eeif   = pir1.7 
.................... #bit  cmif   = pir1.6 
.................... #bit  rcif   = pir1.5 
.................... #bit  txif   = pir1.4 
.................... #bit  ccp1if = pir1.2 
.................... #bit  tmr2if = pir1.1 
.................... #bit  tmr1if = pir1.0 
....................  
.................... //registrador txsta 
.................... #bit  csrc  = txsta.7 
.................... #bit  tx9   = txsta.6 
.................... #bit  txen  = txsta.5 
.................... #bit  sync  = txsta.4 
.................... #bit  brgh =  txsta.2 
.................... #bit  trmt =  txsta.1 
.................... #bit  tx9d =  txsta.0 
....................  
.................... //registrador rcsta 
.................... #bit  spen  = rcsta.7 
.................... #bit  rx9   = rcsta.6 
.................... #bit  sren  = rcsta.5 
.................... #bit  cren  = rcsta.4 
.................... #bit  adden = rcsta.3 
.................... #bit  ferr  = rcsta.2 
.................... #bit  oerr  = rcsta.1 
.................... #bit  rx9d  = rcsta.0 
....................  
....................  
.................... //registrador intcon 
.................... #bit  gie = 0x0b.7 
.................... #bit  peie = 0x0b.6 
.................... #bit  t0ie = 0x0b.5 
.................... #bit  inte = 0x0b.4 
.................... #bit  rbie = 0x0b.3 
.................... #bit  t0if = 0x0b.2 
.................... #bit  intf = 0x0b.1 
.................... #bit  rbif = 0x0b.0 
....................  
.................... #bit  trigger = port_b.3 
.................... #bit  trigger_inv =  port_b.4 
....................  
....................                                                      
....................  
.................... //**************************************************************************** 
.................... //                    CONFIGURAÇÕES DO COMPILADOR 
.................... //**************************************************************************** 
....................  
.................... #use fast_io(a)                  //modo de entrada e saida de dados que 
.................... #use fast_io(b)                  //o compilador nao configura o tris 
....................  
.................... #use delay(clock=20000000)        //clock usual 
*
0020:  MOVLW  28
0021:  MOVWF  04
0022:  BCF    03.7
0023:  MOVF   00,W
0024:  BTFSC  03.2
0025:  GOTO   033
0026:  MOVLW  06
0027:  MOVWF  78
0028:  CLRF   77
0029:  DECFSZ 77,F
002A:  GOTO   029
002B:  DECFSZ 78,F
002C:  GOTO   028
002D:  MOVLW  7B
002E:  MOVWF  77
002F:  DECFSZ 77,F
0030:  GOTO   02F
0031:  DECFSZ 00,F
0032:  GOTO   026
.................... #fuses HS,NOWDT,NOLVP,PUT,NOPROTECT 
....................  
.................... //#rom 0x2100={0b00010010,0x00}    //programa os primeiros dois endereços da eeprom 
....................                                   
....................  
.................... //**************************************************************************** 
.................... //                                BIOS 
.................... //**************************************************************************** 
.................... //****************************  ENTRADAS  ************************************ 
.................... //PORTAS DO TECLADO 
.................... #define  tris_tec    tris_b   //indica qual o port do teclado 
.................... #define  port_tec    port_b 
....................  
.................... //*****************************  SAÍDAS  ************************************* 
.................... #define  saida       port_d 
....................  
.................... //**************************************************************************** 
.................... //                        CONSTANTES E VARIÁVEIS 
.................... //**************************************************************************** 
.................... int   w_temp; 
.................... int   status_temp; 
.................... int   count; 
....................  
....................  
.................... //*************************************************************************** 
.................... //                               DRIVES 
.................... //*************************************************************************** 
.................... #include <teclado_4x4.h> 
.................... /**************************************************************** 
....................       ROTINA DE SCANEAMENTO DE TECLAS DE UMA MATRIZ 
....................       4X4 USANDO UM PORT DO mC  09.05.06 
....................  
.................... VARIAVEIS: 
....................          KEY_TRATA = 1 INDICA QUE EXISTE UMA TECLA NOVA 
....................          KEY_TRATA = 0 INDICA QUE NAO EXISTE UMA TECLA NOVA 
....................          NEW_KEY => RECEBE O VALOR DA TECLA DIGITADA, AS TECLAS VARIAM NO INTERVALO DE 01 ATÉ 0F 
....................          KEY_PRESS = 0 NENHUMA TECLA PRECIONADA 
....................          KEY_PRESS = 1 TECLA PRECIONADA 
....................  
.................... FUNÇÕES: 
....................          void scan_tec(void) ->  INICIA A BUSCA POR UMA TECLA PRECIONADA                                  
....................  
.................... ATUALIZADO: 14.08.10 
.................... *****************************************************************/ 
....................  
.................... //******************************************************** 
.................... //            constantes e variaveis 
.................... //******************************************************** 
....................  
.................... const int linha1[4]={0x01,0x02,0x03,0x0a}; 
.................... const int linha2[4]={0x04,0x05,0x06,0x0b}; 
.................... const int linha3[4]={0x07,0x08,0x09,0x0c}; 
.................... const int linha4[4]={0x0d,0x00,0x0e,0x0f}; 
.................... short int key_trata=0;     //flag: 0-já tratou a tecla, 1-não tratou ainda 
.................... short int key_press = 0;   //flag: 0-não está segurando a tecla, 1-está segurando 
.................... int   new_key; 
.................... int   temp_key; 
.................... //void scan_tec(); 
....................  
....................  
.................... //******************************************************** 
.................... //                      FUNÇÕES 
.................... //******************************************************** 
....................  
.................... scan_tec(){ 
....................        tris_tec=0b11110000; 
*
0013:  MOVLW  F0
0014:  BSF    03.5
0015:  MOVWF  06
....................        port_tec=0b11110000; 
0016:  BCF    03.5
0017:  MOVWF  06
....................        if (port_tec == 0b11110000){ 
0018:  MOVF   06,W
0019:  SUBLW  F0
001A:  BTFSS  03.2
001B:  GOTO   01E
....................        key_press = 0;         //sai sem nenhuma pressionada 
001C:  BCF    25.1
....................        return; 
001D:  GOTO   08C
....................        } 
....................  
....................        delay_ms(20);                   //debouce 
001E:  MOVLW  14
001F:  MOVWF  28
....................  
....................        if (port_tec == 0b11110000){ 
*
0033:  MOVF   06,W
0034:  SUBLW  F0
0035:  BTFSS  03.2
0036:  GOTO   039
....................        key_press = 0;         //verifica se não foi ruido. 
0037:  BCF    25.1
....................        return; 
0038:  GOTO   08C
....................        } 
....................  
....................        if (!key_trata & key_press){       //já tratou a tecla ou esta 
0039:  MOVLW  00
003A:  BTFSS  25.0
003B:  MOVLW  01
003C:  MOVWF  28
003D:  MOVLW  00
003E:  BTFSC  25.1
003F:  MOVLW  01
0040:  ANDWF  28,W
0041:  BTFSC  03.2
0042:  GOTO   044
....................        return; 
0043:  GOTO   08C
....................        } 
....................  
....................        port_tec=0b11111110;         //primeira coluna 
0044:  MOVLW  FE
0045:  MOVWF  06
....................        if (!bit_test(port_tec,4)) new_key=linha1[0]; 
0046:  BTFSC  06.4
0047:  GOTO   04A
0048:  MOVLW  01
0049:  MOVWF  26
....................        if (!bit_test(port_tec,5)) new_key=linha2[0]; 
004A:  BTFSC  06.5
004B:  GOTO   04E
004C:  MOVLW  04
004D:  MOVWF  26
....................        if (!bit_test(port_tec,6)) new_key=linha3[0]; 
004E:  BTFSC  06.6
004F:  GOTO   052
0050:  MOVLW  07
0051:  MOVWF  26
....................        if (!bit_test(port_tec,7)) new_key=linha4[0]; 
0052:  BTFSC  06.7
0053:  GOTO   056
0054:  MOVLW  0D
0055:  MOVWF  26
....................  
....................       port_tec=0b11111101;         //segunda coluna 
0056:  MOVLW  FD
0057:  MOVWF  06
....................        if (!bit_test(port_tec,4)) new_key=linha1[1]; 
0058:  BTFSC  06.4
0059:  GOTO   05C
005A:  MOVLW  02
005B:  MOVWF  26
....................        if (!bit_test(port_tec,5)) new_key=linha2[1]; 
005C:  BTFSC  06.5
005D:  GOTO   060
005E:  MOVLW  05
005F:  MOVWF  26
....................        if (!bit_test(port_tec,6)) new_key=linha3[1]; 
0060:  BTFSC  06.6
0061:  GOTO   064
0062:  MOVLW  08
0063:  MOVWF  26
....................        if (!bit_test(port_tec,7)) new_key=linha4[1]; 
0064:  BTFSS  06.7
0065:  CLRF   26
....................  
....................        port_tec=0b11111011;         //terceira coluna 
0066:  MOVLW  FB
0067:  MOVWF  06
....................        if (!bit_test(port_tec,4)) new_key=linha1[2]; 
0068:  BTFSC  06.4
0069:  GOTO   06C
006A:  MOVLW  03
006B:  MOVWF  26
....................        if (!bit_test(port_tec,5)) new_key=linha2[2]; 
006C:  BTFSC  06.5
006D:  GOTO   070
006E:  MOVLW  06
006F:  MOVWF  26
....................        if (!bit_test(port_tec,6)) new_key=linha3[2]; 
0070:  BTFSC  06.6
0071:  GOTO   074
0072:  MOVLW  09
0073:  MOVWF  26
....................        if (!bit_test(port_tec,7)) new_key=linha4[2]; 
0074:  BTFSC  06.7
0075:  GOTO   078
0076:  MOVLW  0E
0077:  MOVWF  26
....................  
....................        port_tec=0b11110111;         //quarta coluna 
0078:  MOVLW  F7
0079:  MOVWF  06
....................        if (!bit_test(port_tec,4)) new_key=linha1[3]; 
007A:  BTFSC  06.4
007B:  GOTO   07E
007C:  MOVLW  0A
007D:  MOVWF  26
....................        if (!bit_test(port_tec,5)) new_key=linha2[3]; 
007E:  BTFSC  06.5
007F:  GOTO   082
0080:  MOVLW  0B
0081:  MOVWF  26
....................        if (!bit_test(port_tec,6)) new_key=linha3[3]; 
0082:  BTFSC  06.6
0083:  GOTO   086
0084:  MOVLW  0C
0085:  MOVWF  26
....................        if (!bit_test(port_tec,7)) new_key=linha4[3]; 
0086:  BTFSC  06.7
0087:  GOTO   08A
0088:  MOVLW  0F
0089:  MOVWF  26
....................  
....................       key_press = 1; 
008A:  BSF    25.1
....................        key_trata=1; 
008B:  BSF    25.0
.................... } 
008C:  BCF    0A.3
008D:  BCF    0A.4
008E:  GOTO   0CC (RETURN)
....................  
....................  
....................  
....................  
....................  
.................... //**************************************************************************** 
.................... //                       Rotinas da interrupcao 
.................... //**************************************************************************** 
.................... //#inline                     //descomentar se for usar o in_line 
....................  
....................  
....................  
.................... //**************************************************************************** 
.................... //                           INTERRUPÇÕES 
.................... //**************************************************************************** 
.................... #int_global 
.................... void interrupcao(){ 
.................... restart_wdt(); 
*
0004:  CLRWDT
.................... disable_interrupts(global); 
0005:  BCF    0B.6
0006:  BCF    0B.7
0007:  BTFSC  0B.7
0008:  GOTO   006
.................... #asm 
.................... movwf w_temp 
0009:  MOVWF  22
.................... swapf status,w 
000A:  SWAPF  03,W
.................... movwf status_temp 
000B:  MOVWF  23
.................... #endasm 
....................  
....................  
.................... //*************************************************************************** 
.................... //                          FIM DA INTERRUPCAO 
.................... //*************************************************************************** 
.................... enable_interrupts(global); 
000C:  MOVLW  C0
000D:  IORWF  0B,F
.................... #asm 
.................... swapf status_temp,w 
000E:  SWAPF  23,W
.................... movwf status 
000F:  MOVWF  03
.................... swapf w_temp,f 
0010:  SWAPF  22,F
.................... swapf w_temp,w 
0011:  SWAPF  22,W
0012:  RETFIE
.................... #endasm 
.................... } 
....................  
.................... //**************************************************************************** 
.................... //                             Sub-rotinas 
.................... //**************************************************************************** 
.................... trata_tecla(){     
....................       if (key_trata){       
*
008F:  BTFSS  25.0
0090:  GOTO   094
....................       saida = new_key; 
0091:  MOVF   26,W
0092:  MOVWF  08
....................       key_trata = false; 
0093:  BCF    25.0
....................       } 
.................... } 
0094:  BCF    0A.3
0095:  BCF    0A.4
0096:  GOTO   0CD (RETURN)
....................  
....................  
.................... //**************************************************************************** 
.................... //                          Rotina Principal 
.................... //**************************************************************************** 
....................  
.................... void main(){ 
0097:  CLRF   04
0098:  BCF    03.7
0099:  MOVLW  1F
009A:  ANDWF  03,F
009B:  BCF    25.0
009C:  BCF    25.1
009D:  BSF    03.5
009E:  BSF    1F.0
009F:  BSF    1F.1
00A0:  BSF    1F.2
00A1:  BCF    1F.3
.................... //********************** CONFIGURAÇÕES INICIAIS ***************************** 
....................       setup_timer_0(rtcc_internal); //clock interno, prescaler 1:2 
*
00A5:  BSF    03.5
00A6:  MOVF   01,W
00A7:  ANDLW  C0
00A8:  MOVWF  01
....................       setup_timer_1(t1_internal|t1_div_by_8);  
00A9:  MOVLW  B5
00AA:  BCF    03.5
00AB:  MOVWF  10
....................       setup_wdt(wdt_288ms); 
00AC:  MOVLW  0C
00AD:  MOVWF  77
00AE:  CLRF   01
00AF:  MOVLW  81
00B0:  MOVWF  04
00B1:  BCF    03.7
00B2:  MOVF   00,W
00B3:  ANDLW  F0
00B4:  IORLW  07
00B5:  MOVWF  00
00B6:  CLRWDT
00B7:  MOVF   00,W
00B8:  ANDLW  F7
00B9:  BTFSC  77.3
00BA:  ANDLW  F0
00BB:  IORWF  77,W
00BC:  MOVWF  00
....................       disable_interrupts(global); 
00BD:  BCF    0B.6
00BE:  BCF    0B.7
00BF:  BTFSC  0B.7
00C0:  GOTO   0BE
....................       port_b_pullups(true);   //Ativa os pullups do port B     
00C1:  BSF    03.5
00C2:  BCF    01.7
....................  
.................... //    Configuração do tris 
.................... //    Bit porta: 76543210 
....................       tris_a = 0b00000000; 
00C3:  CLRF   05
.................... //      tris_b = 0b00000000;  //Definido no arquivo drive do teclado 
....................       tris_c = 0b00000000; 
00C4:  CLRF   07
....................       tris_d = 0b00000000;    
00C5:  CLRF   08
....................       tris_e = 0b00000000; 
00C6:  CLRF   09
....................        
....................  
.................... //******************** INICIALIZAÇÃO DE VARIÁVEIS *************************** 
....................       key_trata = false; 
00C7:  BCF    03.5
00C8:  BCF    25.0
....................       saida = 0; 
00C9:  CLRF   08
.................... //**************************************************************************** 
.................... //                             INICIO DO LOOP 
.................... //**************************************************************************** 
....................       while(1){   
....................       restart_wdt(); 
00CA:  CLRWDT
....................       scan_tec();       //Verifica se alguma tecla foi digitada. 
00CB:  GOTO   013
....................       trata_tecla();    //Realiza o tratamento da tecla. 
00CC:  GOTO   08F
....................       } 
00CD:  GOTO   0CA
.................... //********************************* FIM ************************************** 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
00CE:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT NOPROTECT BROWNOUT NOLVP NOCPD NOWRT NODEBUG
