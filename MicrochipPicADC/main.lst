CCS PCM C Compiler, Version 4.104, 5967               17-set-17 12:25

               Filename: C:\DADOS\projeto\MicrochipPicADC\main.lst

               ROM used: 1097 words (13%)
                         Largest free fragment is 2048
               RAM used: 19 (5%) at main() level
                         43 (12%) worst case
               Stack:    6 worst case (5 in main + 1 for interrupts)

*
0000:  MOVLW  03
0001:  MOVWF  0A
0002:  GOTO   364
0003:  NOP
.................... //**************************************************************************** 
.................... //                EXEMPLO CONVERSOR ANALÓGICO DIGITAL 
.................... //**************************************************************************** 
.................... //Compilador CCS PCWH Ver 4.104 
....................  
.................... #include <16F877.h>              //include do 16F628 
.................... //////// Standard Header file for the PIC16F877 device //////////////// 
.................... #device PIC16F877 
.................... #list 
....................  
.................... #device  ADC=10       //Dispositivo com 10Bits de conversão (OBRIGATÓRIO!) 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
036D:  BCF    03.5
036E:  CLRF   20
036F:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <16f8x_registradores.h>//MAPEAMENTO DE MEÓRIA DOS REGISTRADORES 
.................... //********************************************************** 
.................... //INCLUDE DE MAPEAMENTO DE MEÓRIA DOS REGISTRADORES 
.................... //ESPECIAIS E BITS DOS MESMOS PARA OS mC 16f87X 
.................... //********************************************************** 
....................  
.................... #byte option_reg = 0x81 
.................... #byte status = 0x03 
.................... #byte tris_a = 0x85        //#byte - define o endereco do 
.................... #byte tris_b = 0x86        //registrador no banco de memoria 
.................... #byte tris_c = 0x87        //de acordo com o datasheet 
.................... #byte tris_d = 0x88        //de acordo com o datasheet 
.................... #byte tris_e = 0x89        //de acordo com o datasheet 
.................... #byte port_a = 0x05 
.................... #byte port_b = 0x06 
.................... #byte port_c = 0x07 
.................... #byte port_d = 0x08 
.................... #byte port_e = 0x09 
.................... #byte intcon = 0x0b 
....................  
.................... //USART 
.................... #byte txsta = 0x98 
.................... #byte rcsta = 0x18 
.................... #byte spbrg = 0x99 
.................... #byte txreg = 0x19 
.................... #byte rcreg = 0x1a    
....................  
.................... #byte pir1 = 0x0c 
.................... #byte pie1 = 0x8c 
....................  
.................... //registrador pie1 
.................... #bit  eeie   = pie1.7 
.................... #bit  cmie   = pie1.6 
.................... #bit  rcie   = pie1.5 
.................... #bit  txie   = pie1.4 
.................... #bit  ccp1ie = pie1.2 
.................... #bit  tmr2ie = pie1.1 
.................... #bit  tmr1ie = pie1.0 
....................  
.................... //registrador pir1 
.................... #bit  eeif   = pir1.7 
.................... #bit  cmif   = pir1.6 
.................... #bit  rcif   = pir1.5 
.................... #bit  txif   = pir1.4 
.................... #bit  ccp1if = pir1.2 
.................... #bit  tmr2if = pir1.1 
.................... #bit  tmr1if = pir1.0 
....................  
.................... //registrador txsta 
.................... #bit  csrc  = txsta.7 
.................... #bit  tx9   = txsta.6 
.................... #bit  txen  = txsta.5 
.................... #bit  sync  = txsta.4 
.................... #bit  brgh =  txsta.2 
.................... #bit  trmt =  txsta.1 
.................... #bit  tx9d =  txsta.0 
....................  
.................... //registrador rcsta 
.................... #bit  spen  = rcsta.7 
.................... #bit  rx9   = rcsta.6 
.................... #bit  sren  = rcsta.5 
.................... #bit  cren  = rcsta.4 
.................... #bit  adden = rcsta.3 
.................... #bit  ferr  = rcsta.2 
.................... #bit  oerr  = rcsta.1 
.................... #bit  rx9d  = rcsta.0 
....................  
....................  
.................... //registrador intcon 
.................... #bit  gie = 0x0b.7 
.................... #bit  peie = 0x0b.6 
.................... #bit  t0ie = 0x0b.5 
.................... #bit  inte = 0x0b.4 
.................... #bit  rbie = 0x0b.3 
.................... #bit  t0if = 0x0b.2 
.................... #bit  intf = 0x0b.1 
.................... #bit  rbif = 0x0b.0 
....................  
.................... #bit  trigger = port_b.3 
.................... #bit  trigger_inv =  port_b.4 
....................  
....................                                                     
.................... //**************************************************************************** 
.................... //                    CONFIGURAÇÕES DO COMPILADOR 
.................... //**************************************************************************** 
....................  
.................... #use fast_io(a)                  //modo de entrada e saida de dados que 
.................... #use fast_io(b)                  //o compilador nao configura o tris 
....................  
.................... #use delay(clock=20000000)        //clock usual 
*
003B:  MOVLW  3A
003C:  MOVWF  04
003D:  BCF    03.7
003E:  MOVF   00,W
003F:  BTFSC  03.2
0040:  GOTO   04E
0041:  MOVLW  06
0042:  MOVWF  78
0043:  CLRF   77
0044:  DECFSZ 77,F
0045:  GOTO   044
0046:  DECFSZ 78,F
0047:  GOTO   043
0048:  MOVLW  7B
0049:  MOVWF  77
004A:  DECFSZ 77,F
004B:  GOTO   04A
004C:  DECFSZ 00,F
004D:  GOTO   041
004E:  RETURN
.................... #fuses HS,NOWDT,NOLVP,PUT,NOPROTECT 
....................  
.................... //#rom 0x2100={0b00010010,0x00}    //programa os primeiros dois endereços da eeprom 
....................                                   
.................... //**************************************************************************** 
.................... //                                BIOS 
.................... //**************************************************************************** 
.................... //****************************  ENTRADAS  ************************************ 
.................... #define  analogico1       PIN_A0 
.................... #define  analogico2       PIN_A1 
....................  
.................... //*****************************  SAÍDAS  ************************************* 
....................  
.................... // As definições a seguir são utilizadas para acesso aos pinos do display 
.................... // caso o pino RW não seja utilizado, comente a definição lcd_rw 
.................... #ifndef lcd_enable 
....................    #define lcd_enable     pin_b5      // pino enable do LCD 
....................    #define lcd_rs         pin_b4      // pino rs do LCD 
....................    //#define lcd_rw      pin_b2      // pino rw do LCD 
....................    #define lcd_d4         pin_b0      // pino de dados d4 do LCD 
....................    #define lcd_d5         pin_b1      // pino de dados d5 do LCD 
....................    #define lcd_d6         pin_b2      // pino de dados d6 do LCD 
....................    #define lcd_d7         pin_b3      // pino de dados d7 do LCD 
.................... #endif 
....................  
.................... //**************************************************************************** 
.................... //                        CONSTANTES E VARIÁVEIS 
.................... //**************************************************************************** 
.................... #define  VREF  4.88E-3;    //Conversão de 14Bits 5V/2^10 
....................  
.................... int   w_temp; 
.................... int   status_temp; 
.................... float ref; 
.................... float valor_adc; 
....................  
.................... //*************************************************************************** 
.................... //                               DRIVES 
.................... //*************************************************************************** 
.................... #include "c:\dados\projeto\includes\lcd.h" 
....................  
.................... /************************************************************************ 
....................         MOD_LCD.C - Biblioteca de manipulação de módulo LCD 
....................                         Autor: Fábio Pereira                                                 
....................  
.................... FUNÇÕES: 
....................          void lcd_ini(void) ->  rotina de inicialização do display 
....................          void lcd_pos_xy( byte x, byte y) -> posiciona o cursor  
....................          void lcd_escreve( char c) ->  envia caractere para o display ou 
....................                                        uma string ex. lcd_escreve("R.Johnson"); 
....................                                        argumentos ex. lcd_escreve('\f'); 
....................                                        \f -> apaga o display e retorna a primeira posição da primeira linha 
....................                                        \r -> passa para linha de baixo "enter"    
....................                                        \n -> sem uso   
.................... ATUALIZADO: 14.08.10                                               
.................... /************************************************************************/ 
....................  
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereço da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqüência de inicialização do módulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... /* FUNÇÃO DESABILITADA DEVIDO AO DESUSO 
....................  
.................... byte lcd_le_byte() 
.................... // lê um byte do LCD (somente com pino RW) 
.................... { 
....................    byte dado; 
....................    // configura os pinos de dados como entradas 
....................    input(lcd_d4); 
....................    input(lcd_d5); 
....................    input(lcd_d6); 
....................    input(lcd_d7); 
....................    // se o pino rw for utilizado, coloca em 1 
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_high(lcd_enable); // habilita display 
....................    dado = 0;   // zera a variável de leitura 
....................    // lê os quatro bits mais significativos 
....................    if (input(lcd_d7)) bit_set(dado,7); 
....................    if (input(lcd_d6)) bit_set(dado,6); 
....................    if (input(lcd_d5)) bit_set(dado,5); 
....................    if (input(lcd_d4)) bit_set(dado,4); 
....................    // dá um pulso na linha enable 
....................    output_low(lcd_enable); 
....................    output_high(lcd_enable); 
....................    // lê os quatro bits menos significativos 
....................    if (input(lcd_d7)) bit_set(dado,3); 
....................    if (input(lcd_d6)) bit_set(dado,2); 
....................    if (input(lcd_d5)) bit_set(dado,1); 
....................    if (input(lcd_d4)) bit_set(dado,0); 
....................    output_low(lcd_enable);   // desabilita o display 
....................    return dado;   // retorna o byte lido 
.................... } 
.................... */ 
....................  
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
....................    // coloca os quatro bits nas saidas 
....................    output_bit(lcd_d4,bit_test(dado,0)); 
004F:  BTFSC  41.0
0050:  GOTO   053
0051:  BCF    06.0
0052:  GOTO   054
0053:  BSF    06.0
....................    output_bit(lcd_d5,bit_test(dado,1)); 
0054:  BTFSC  41.1
0055:  GOTO   058
0056:  BCF    06.1
0057:  GOTO   059
0058:  BSF    06.1
....................    output_bit(lcd_d6,bit_test(dado,2)); 
0059:  BTFSC  41.2
005A:  GOTO   05D
005B:  BCF    06.2
005C:  GOTO   05E
005D:  BSF    06.2
....................    output_bit(lcd_d7,bit_test(dado,3)); 
005E:  BTFSC  41.3
005F:  GOTO   062
0060:  BCF    06.3
0061:  GOTO   063
0062:  BSF    06.3
....................    // dá um pulso na linha enable 
....................    output_high(lcd_enable); 
0063:  BSF    06.5
....................    output_low(lcd_enable); 
0064:  BCF    06.5
.................... } 
0065:  RETURN
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
....................    // coloca a linha rs em 0 
....................    output_low(lcd_rs); 
0066:  BCF    06.4
....................    // aguarda o display ficar desocupado 
....................    //while ( bit_test(lcd_le_byte(),7) ) ; 
....................    // configura a linha rs dependendo do modo selecionado 
....................    output_bit(lcd_rs,endereco); 
0067:  MOVF   3E,F
0068:  BTFSS  03.2
0069:  GOTO   06C
006A:  BCF    06.4
006B:  GOTO   06D
006C:  BSF    06.4
....................    delay_us(100);   // aguarda 100 us 
006D:  MOVLW  A6
006E:  MOVWF  77
006F:  DECFSZ 77,F
0070:  GOTO   06F
0071:  NOP
....................    // caso a linha rw esteja definida, coloca em 0 
....................    #ifdef lcd_rw 
....................       output_low(lcd_rw); 
....................    #endif 
....................    // desativa linha enable 
....................    output_low(lcd_enable); 
0072:  BCF    06.5
....................    // envia a primeira parte do byte 
....................    lcd_envia_nibble(dado >> 4); 
0073:  SWAPF  3F,W
0074:  MOVWF  40
0075:  MOVLW  0F
0076:  ANDWF  40,F
0077:  MOVF   40,W
0078:  MOVWF  41
0079:  CALL   04F
....................    // envia a segunda parte do byte 
....................    lcd_envia_nibble(dado & 0x0f); 
007A:  MOVF   3F,W
007B:  ANDLW  0F
007C:  MOVWF  40
007D:  MOVWF  41
007E:  CALL   04F
.................... } 
007F:  RETURN
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicialização do display 
.................... { 
....................    byte conta; 
....................    output_low(lcd_d4); 
0080:  BCF    06.0
....................    output_low(lcd_d5); 
0081:  BCF    06.1
....................    output_low(lcd_d6); 
0082:  BCF    06.2
....................    output_low(lcd_d7); 
0083:  BCF    06.3
....................    output_low(lcd_rs); 
0084:  BCF    06.4
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_low(lcd_enable); 
0085:  BCF    06.5
....................    delay_ms(15); 
0086:  MOVLW  0F
0087:  MOVWF  3A
0088:  CALL   03B
....................    // envia uma seqüência de 3 vezes 0x03 
....................    // e depois 0x02 para configurar o módulo 
....................    // para modo de 4 bits 
....................    for(conta=1;conta<=3;++conta) 
0089:  MOVLW  01
008A:  MOVWF  2C
008B:  MOVF   2C,W
008C:  SUBLW  03
008D:  BTFSS  03.0
008E:  GOTO   097
....................    { 
....................       lcd_envia_nibble(3); 
008F:  MOVLW  03
0090:  MOVWF  41
0091:  CALL   04F
....................       delay_ms(5); 
0092:  MOVLW  05
0093:  MOVWF  3A
0094:  CALL   03B
....................    } 
0095:  INCF   2C,F
0096:  GOTO   08B
....................    lcd_envia_nibble(2); 
0097:  MOVLW  02
0098:  MOVWF  41
0099:  CALL   04F
....................    // envia string de inicialização do display 
....................    for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
009A:  CLRF   2C
009B:  MOVF   2C,W
009C:  SUBLW  03
009D:  BTFSS  03.0
009E:  GOTO   0A8
009F:  MOVF   2C,W
00A0:  CALL   013
00A1:  MOVWF  2D
00A2:  CLRF   3E
00A3:  MOVF   2D,W
00A4:  MOVWF  3F
00A5:  CALL   066
00A6:  INCF   2C,F
00A7:  GOTO   09B
.................... } 
00A8:  BCF    0A.3
00A9:  BCF    0A.4
00AA:  GOTO   394 (RETURN)
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
00AB:  DECFSZ 3B,W
00AC:  GOTO   0AE
00AD:  GOTO   0B1
....................       endereco = lcd_seg_lin; 
00AE:  MOVLW  40
00AF:  MOVWF  3C
....................    else 
00B0:  GOTO   0B2
....................       endereco = 0; 
00B1:  CLRF   3C
....................    endereco += x-1; 
00B2:  MOVLW  01
00B3:  SUBWF  3A,W
00B4:  ADDWF  3C,F
....................    lcd_envia_byte(0,0x80|endereco); 
00B5:  MOVF   3C,W
00B6:  IORLW  80
00B7:  MOVWF  3D
00B8:  CLRF   3E
00B9:  MOVF   3D,W
00BA:  MOVWF  3F
00BB:  CALL   066
.................... } 
00BC:  RETURN
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
....................    { 
00BD:  MOVF   39,W
00BE:  XORLW  0C
00BF:  BTFSC  03.2
00C0:  GOTO   0CB
00C1:  XORLW  06
00C2:  BTFSC  03.2
00C3:  GOTO   0D3
00C4:  XORLW  07
00C5:  BTFSC  03.2
00C6:  GOTO   0D3
00C7:  XORLW  05
00C8:  BTFSC  03.2
00C9:  GOTO   0D9
00CA:  GOTO   0DE
....................      case '\f'    :   lcd_envia_byte(0,1); 
00CB:  CLRF   3E
00CC:  MOVLW  01
00CD:  MOVWF  3F
00CE:  CALL   066
....................               delay_ms(2); 
00CF:  MOVLW  02
00D0:  MOVWF  3A
00D1:  CALL   03B
....................             break; 
00D2:  GOTO   0E4
....................      case '\n'   : 
....................      case '\r'    :   lcd_pos_xy(1,2); 
00D3:  MOVLW  01
00D4:  MOVWF  3A
00D5:  MOVLW  02
00D6:  MOVWF  3B
00D7:  CALL   0AB
....................               break; 
00D8:  GOTO   0E4
....................      case '\b'    :   lcd_envia_byte(0,0x10); 
00D9:  CLRF   3E
00DA:  MOVLW  10
00DB:  MOVWF  3F
00DC:  CALL   066
....................               break; 
00DD:  GOTO   0E4
....................      default   :   lcd_envia_byte(1,c); 
00DE:  MOVLW  01
00DF:  MOVWF  3E
00E0:  MOVF   39,W
00E1:  MOVWF  3F
00E2:  CALL   066
....................               break; 
00E3:  GOTO   0E4
....................    } 
.................... } 
00E4:  RETURN
....................  
....................  
.................... /* FUNÇÃO DESABILITADA DEVIDO AO DESUSO 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
....................    char valor; 
....................    // seleciona a posição do caractere 
....................    lcd_pos_xy(x,y); 
....................    // ativa rs 
....................    output_high(lcd_rs); 
....................    // lê o caractere 
....................    valor = lcd_le_byte(); 
....................    // desativa rs 
....................    output_low(lcd_rs); 
....................    // retorna o valor do caractere 
....................    return valor; 
.................... } 
.................... */ 
....................  
....................  
.................... //**************************************************************************** 
.................... //                       Rotinas da interrupcao 
.................... //**************************************************************************** 
.................... //#inline                     //descomentar se for usar o in_line 
....................  
.................... //**************************************************************************** 
.................... //                           INTERRUPÇÕES 
.................... //**************************************************************************** 
.................... #int_global 
.................... void interrupcao(){ 
.................... restart_wdt(); 
*
0004:  CLRWDT
.................... disable_interrupts(global); 
0005:  BCF    0B.6
0006:  BCF    0B.7
0007:  BTFSC  0B.7
0008:  GOTO   006
.................... #asm 
.................... movwf w_temp 
0009:  MOVWF  22
.................... swapf status,w 
000A:  SWAPF  03,W
.................... movwf status_temp 
000B:  MOVWF  23
.................... #endasm 
....................  
....................  
.................... //*************************************************************************** 
.................... //                          FIM DA INTERRUPCAO 
.................... //*************************************************************************** 
.................... enable_interrupts(global); 
000C:  MOVLW  C0
000D:  IORWF  0B,F
.................... #asm 
.................... swapf status_temp,w 
000E:  SWAPF  23,W
.................... movwf status 
000F:  MOVWF  03
.................... swapf w_temp,f 
0010:  SWAPF  22,F
.................... swapf w_temp,w 
0011:  SWAPF  22,W
0012:  RETFIE
.................... #endasm 
.................... } 
....................  
.................... //**************************************************************************** 
.................... //                             Sub-rotinas 
.................... //**************************************************************************** 
.................... long int le_adc(int canal){ 
....................    set_adc_channel(canal); 
*
00E5:  RLF    2C,W
00E6:  MOVWF  77
00E7:  RLF    77,F
00E8:  RLF    77,F
00E9:  MOVLW  F8
00EA:  ANDWF  77,F
00EB:  MOVF   1F,W
00EC:  ANDLW  C7
00ED:  IORWF  77,W
00EE:  MOVWF  1F
....................    delay_us(10); 
00EF:  MOVLW  10
00F0:  MOVWF  77
00F1:  DECFSZ 77,F
00F2:  GOTO   0F1
00F3:  NOP
....................    return read_adc(); 
00F4:  BSF    1F.2
00F5:  BTFSC  1F.2
00F6:  GOTO   0F5
00F7:  MOVF   1E,W
00F8:  MOVWF  7A
00F9:  BSF    03.5
00FA:  MOVF   1E,W
00FB:  MOVWF  78
00FC:  MOVF   7A,W
00FD:  MOVWF  79
.................... } 
00FE:  BCF    03.5
00FF:  RETURN
....................  
.................... float converte(long int conv){ 
....................    return conv*ref; 
*
0175:  MOVF   2F,W
0176:  MOVWF  31
0177:  MOVF   2E,W
0178:  MOVWF  30
*
0195:  MOVF   7A,W
0196:  MOVWF  3C
0197:  MOVF   79,W
0198:  MOVWF  3B
0199:  MOVF   78,W
019A:  MOVWF  3A
019B:  MOVF   77,W
019C:  MOVWF  39
019D:  MOVF   27,W
019E:  MOVWF  40
019F:  MOVF   26,W
01A0:  MOVWF  3F
01A1:  MOVF   25,W
01A2:  MOVWF  3E
01A3:  MOVF   24,W
01A4:  MOVWF  3D
01A5:  CALL   100
.................... } 
01A6:  RETURN
....................  
.................... //**************************************************************************** 
.................... //                          Rotina Principal 
.................... //**************************************************************************** 
....................  
.................... void main(){ 
*
0364:  CLRF   04
0365:  BCF    03.7
0366:  MOVLW  1F
0367:  ANDWF  03,F
0368:  BSF    03.5
0369:  BSF    1F.0
036A:  BSF    1F.1
036B:  BSF    1F.2
036C:  BCF    1F.3
.................... //********************** CONFIGURAÇÕES INICIAIS ***************************** 
....................       setup_timer_0(rtcc_internal); //clock interno 
*
0370:  BSF    03.5
0371:  MOVF   01,W
0372:  ANDLW  C0
0373:  MOVWF  01
....................       setup_wdt(wdt_288ms); 
0374:  MOVLW  0C
0375:  MOVWF  77
0376:  BCF    03.5
0377:  CLRF   01
0378:  MOVLW  81
0379:  MOVWF  04
037A:  BCF    03.7
037B:  MOVF   00,W
037C:  ANDLW  F0
037D:  IORLW  07
037E:  MOVWF  00
037F:  CLRWDT
0380:  MOVF   00,W
0381:  ANDLW  F7
0382:  BTFSC  77.3
0383:  ANDLW  F0
0384:  IORWF  77,W
0385:  MOVWF  00
....................       disable_interrupts(global); 
0386:  BCF    0B.6
0387:  BCF    0B.7
0388:  BTFSC  0B.7
0389:  GOTO   387
....................       port_b_pullups(false);    //sem pull-up 
038A:  BSF    03.5
038B:  BSF    01.7
....................  
.................... //    Configuração do tris 
.................... //    Bit porta: 76543210 
....................       tris_a = 0b00000011; 
038C:  MOVLW  03
038D:  MOVWF  05
....................       tris_b = 0b00000000; 
038E:  CLRF   06
....................       tris_c = 0b00000000; 
038F:  CLRF   07
....................       tris_d = 0b00000000; 
0390:  CLRF   08
....................       tris_e = 0b00000000; 
0391:  CLRF   09
....................        
.................... //    Inicialização do LCD 
....................       lcd_ini(); 
0392:  BCF    03.5
0393:  GOTO   080
....................       delay_ms(100); 
0394:  MOVLW  64
0395:  MOVWF  3A
0396:  CALL   03B
....................       lcd_escreve('\f');   //Limpa o lcd 
0397:  MOVLW  0C
0398:  MOVWF  39
0399:  CALL   0BD
....................       lcd_escreve('\b'); 
039A:  MOVLW  08
039B:  MOVWF  39
039C:  CALL   0BD
....................   
....................       setup_adc(ADC_CLOCK_INTERNAL);      //Configura o adc para clock interno 
039D:  BSF    1F.6
039E:  BSF    1F.7
039F:  BSF    03.5
03A0:  BSF    1F.7
03A1:  BCF    03.5
03A2:  BSF    1F.0
....................       setup_adc_ports(RA0_RA1_RA3_ANALOG);    //Entradas RA0 e RA1 como analógicas 
03A3:  BSF    03.5
03A4:  BCF    1F.0
03A5:  BCF    1F.1
03A6:  BSF    1F.2
03A7:  BCF    1F.3
....................        
.................... //******************** INICIALIZAÇÃO DE VARIÁVEIS *************************** 
....................       ref = VREF; 
03A8:  MOVLW  68
03A9:  BCF    03.5
03AA:  MOVWF  27
03AB:  MOVLW  E8
03AC:  MOVWF  26
03AD:  MOVLW  1F
03AE:  MOVWF  25
03AF:  MOVLW  77
03B0:  MOVWF  24
....................        
.................... //**************************************************************************** 
.................... //                             INICIO DO LOOP 
.................... //**************************************************************************** 
....................       while(1){   
....................       restart_wdt(); 
03B1:  CLRWDT
....................        
....................       // Tela 1 - Canal 0 
....................       valor_adc = converte(le_adc(0)); //Converte a tensão atual na entrada 
03B2:  CLRF   2C
03B3:  CALL   0E5
03B4:  MOVF   79,W
03B5:  MOVWF  2D
03B6:  MOVF   78,W
03B7:  MOVWF  2C
03B8:  MOVF   79,W
03B9:  MOVWF  2F
03BA:  MOVF   78,W
03BB:  MOVWF  2E
03BC:  CALL   175
03BD:  MOVF   7A,W
03BE:  MOVWF  2B
03BF:  MOVF   79,W
03C0:  MOVWF  2A
03C1:  MOVF   78,W
03C2:  MOVWF  29
03C3:  MOVF   77,W
03C4:  MOVWF  28
....................       lcd_pos_xy(1,1); 
03C5:  MOVLW  01
03C6:  MOVWF  3A
03C7:  MOVWF  3B
03C8:  CALL   0AB
....................       lcd_escreve("ENTRADA ANALOG 1"); 
03C9:  MOVLW  1B
03CA:  BSF    03.6
03CB:  MOVWF  0D
03CC:  MOVLW  00
03CD:  MOVWF  0F
03CE:  BCF    03.6
03CF:  CALL   1A7
....................       lcd_pos_xy(1,2); 
03D0:  MOVLW  01
03D1:  MOVWF  3A
03D2:  MOVLW  02
03D3:  MOVWF  3B
03D4:  CALL   0AB
....................       printf(lcd_escreve,"Valor: %1.3fV",valor_adc); 
03D5:  MOVLW  24
03D6:  BSF    03.6
03D7:  MOVWF  0D
03D8:  MOVLW  00
03D9:  MOVWF  0F
03DA:  BCF    03.0
03DB:  MOVLW  07
03DC:  BCF    03.6
03DD:  MOVWF  2C
03DE:  CALL   1ED
03DF:  MOVLW  89
03E0:  MOVWF  04
03E1:  MOVF   2B,W
03E2:  MOVWF  2F
03E3:  MOVF   2A,W
03E4:  MOVWF  2E
03E5:  MOVF   29,W
03E6:  MOVWF  2D
03E7:  MOVF   28,W
03E8:  MOVWF  2C
03E9:  MOVLW  03
03EA:  MOVWF  30
03EB:  CALL   27D
03EC:  MOVLW  56
03ED:  MOVWF  39
03EE:  CALL   0BD
....................       delay_ms(5000); 
03EF:  MOVLW  14
03F0:  MOVWF  2C
03F1:  MOVLW  FA
03F2:  MOVWF  3A
03F3:  CALL   03B
03F4:  DECFSZ 2C,F
03F5:  GOTO   3F1
....................       lcd_escreve('\f');   //Limpa o lcd 
03F6:  MOVLW  0C
03F7:  MOVWF  39
03F8:  CALL   0BD
....................       lcd_escreve('\b'); 
03F9:  MOVLW  08
03FA:  MOVWF  39
03FB:  CALL   0BD
....................  
....................       // Tela 2 - Canal 1 
....................       valor_adc = converte(le_adc(1)); //Converte a tensão atual na entrada 
03FC:  MOVLW  01
03FD:  MOVWF  2C
03FE:  CALL   0E5
03FF:  MOVF   79,W
0400:  MOVWF  2D
0401:  MOVF   78,W
0402:  MOVWF  2C
0403:  MOVF   79,W
0404:  MOVWF  2F
0405:  MOVF   78,W
0406:  MOVWF  2E
0407:  CALL   175
0408:  MOVF   7A,W
0409:  MOVWF  2B
040A:  MOVF   79,W
040B:  MOVWF  2A
040C:  MOVF   78,W
040D:  MOVWF  29
040E:  MOVF   77,W
040F:  MOVWF  28
....................       lcd_pos_xy(1,1); 
0410:  MOVLW  01
0411:  MOVWF  3A
0412:  MOVWF  3B
0413:  CALL   0AB
....................       lcd_escreve("ENTRADA ANALOG 2"); 
0414:  MOVLW  2B
0415:  BSF    03.6
0416:  MOVWF  0D
0417:  MOVLW  00
0418:  MOVWF  0F
0419:  BCF    03.6
041A:  CALL   1A7
....................       lcd_pos_xy(1,2); 
041B:  MOVLW  01
041C:  MOVWF  3A
041D:  MOVLW  02
041E:  MOVWF  3B
041F:  CALL   0AB
....................       printf(lcd_escreve,"Valor: %1.3fV",valor_adc); 
0420:  MOVLW  34
0421:  BSF    03.6
0422:  MOVWF  0D
0423:  MOVLW  00
0424:  MOVWF  0F
0425:  BCF    03.0
0426:  MOVLW  07
0427:  BCF    03.6
0428:  MOVWF  2C
0429:  CALL   1ED
042A:  MOVLW  89
042B:  MOVWF  04
042C:  MOVF   2B,W
042D:  MOVWF  2F
042E:  MOVF   2A,W
042F:  MOVWF  2E
0430:  MOVF   29,W
0431:  MOVWF  2D
0432:  MOVF   28,W
0433:  MOVWF  2C
0434:  MOVLW  03
0435:  MOVWF  30
0436:  CALL   27D
0437:  MOVLW  56
0438:  MOVWF  39
0439:  CALL   0BD
....................       delay_ms(5000); 
043A:  MOVLW  14
043B:  MOVWF  2C
043C:  MOVLW  FA
043D:  MOVWF  3A
043E:  CALL   03B
043F:  DECFSZ 2C,F
0440:  GOTO   43C
....................       lcd_escreve('\f');   //Limpa o lcd 
0441:  MOVLW  0C
0442:  MOVWF  39
0443:  CALL   0BD
....................       lcd_escreve('\b'); 
0444:  MOVLW  08
0445:  MOVWF  39
0446:  CALL   0BD
....................       } 
0447:  GOTO   3B1
.................... //********************************* FIM ************************************** 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
0448:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT NOPROTECT BROWNOUT NOLVP NOCPD NOWRT NODEBUG
