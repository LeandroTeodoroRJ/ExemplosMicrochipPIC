CCS PCH C Compiler, Version 4.104, 5967               29-out-17 16:35

               Filename: C:\DADOS\projeto\MicrochipPic18AsyncUsart\main.lst

               ROM used: 460 bytes (1%)
                         Largest free fragment is 32304
               RAM used: 26 (2%) at main() level
                         28 (2%) worst case
               Stack:    4 worst case (2 in main + 2 for interrupts)

*
0000:  GOTO   014C
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.5
004A:  GOTO   0054
004E:  BTFSC  F9E.5
0050:  GOTO   00D4
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... //**************************************************************************** 
.................... //                      PIC 18 - ASYNC USART MODE 
.................... //**************************************************************************** 
.................... //Compilador CCS PCWH Ver 4.104 
....................  
.................... #include <18F4520.h>              //include do 16F628 
.................... //////// Standard Header file for the PIC18F4520 device //////////////// 
.................... #device PIC18F4520 
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <18F4520_registradores.h>//MAPEAMENTO DE MEÓRIA DOS REGISTRADORES 
.................... //********************************************************** 
.................... //INCLUDE DE MAPEAMENTO DE MEÓRIA DOS REGISTRADORES 
.................... //ESPECIAIS E BITS DOS MESMOS PARA O mC 18F4520 
.................... //********************************************************** 
....................  
.................... #byte status = 0xFD8        
.................... #byte tris_a = 0xF92        //#byte - define o endereco do 
.................... #byte tris_b = 0xF93        //registrador no banco de memoria 
.................... #byte tris_c = 0xF94        //de acordo com o datasheet 
.................... #byte tris_d = 0xF95        //de acordo com o datasheet 
.................... #byte tris_e = 0xF96        //de acordo com o datasheet 
.................... #byte port_a = 0xF80 
.................... #byte port_b = 0xF81 
.................... #byte port_c = 0xF82 
.................... #byte port_d = 0xF83 
.................... #byte port_e = 0xF84 
.................... #byte intcon = 0xFF2 
.................... #byte pir1 =   0xF9E 
.................... #byte pie1 =   0xF9D 
....................  
.................... //registrador pir1 
.................... #bit  pspif  = pir1.7 
.................... #bit  adif   = pir1.6 
.................... #bit  rcif   = pir1.5 
.................... #bit  txif   = pir1.4 
.................... #bit  sspif  = pir1.3 
.................... #bit  ccp1if = pir1.2 
.................... #bit  tmr2if = pir1.1 
.................... #bit  tmr1if = pir1.0 
....................  
.................... //registrador pie1 
.................... #bit  pspie  = pie1.7 
.................... #bit  adie   = pie1.6 
.................... #bit  rcie   = pie1.5 
.................... #bit  txie   = pie1.4 
.................... #bit  sspie  = pie1.3 
.................... #bit  ccp1ie = pie1.2 
.................... #bit  tmr2ie = pie1.1 
.................... #bit  tmr1ie = pie1.0 
....................  
.................... //USART 
.................... #byte txsta = 0xFAC 
.................... #byte rcsta = 0xFAB 
.................... #byte spbrg = 0xFAF 
.................... #byte spbrgh= 0xFB0 
.................... #byte txreg = 0xFAD 
.................... #byte rcreg = 0xFAE  
....................  
.................... //registrador txsta 
.................... #bit  csrc  = txsta.7 
.................... #bit  tx9   = txsta.6 
.................... #bit  txen  = txsta.5 
.................... #bit  sync  = txsta.4 
.................... #bit  sendb = txsta.3 
.................... #bit  brgh =  txsta.2 
.................... #bit  trmt =  txsta.1 
.................... #bit  tx9d =  txsta.0 
....................  
.................... //registrador rcsta 
.................... #bit  spen  = rcsta.7 
.................... #bit  rx9   = rcsta.6 
.................... #bit  sren  = rcsta.5 
.................... #bit  cren  = rcsta.4 
.................... #bit  adden = rcsta.3 
.................... #bit  ferr  = rcsta.2 
.................... #bit  oerr  = rcsta.1 
.................... #bit  rx9d  = rcsta.0 
....................  
.................... //registrador intcon 
.................... #bit  gie  = 0x0b.7 
.................... #bit  peie = 0x0b.6 
.................... #bit  t0ie = 0x0b.5 
.................... #bit  inte = 0x0b.4 
.................... #bit  rbie = 0x0b.3 
.................... #bit  t0if = 0x0b.2 
.................... #bit  intf = 0x0b.1 
.................... #bit  rbif = 0x0b.0 
....................  
....................  
....................  
....................  
....................                                                      
....................  
.................... //**************************************************************************** 
.................... //                    CONFIGURAÇÕES DO COMPILADOR 
.................... //**************************************************************************** 
....................  
.................... #use fast_io(a)                  //modo de entrada e saida de dados que 
.................... #use fast_io(b)                  //o compilador nao configura o tris 
....................  
.................... #use delay(clock=20000000)        //clock usual 
*
0106:  CLRF   FEA
0108:  MOVLW  1A
010A:  MOVWF  FE9
010C:  MOVF   FEF,W
010E:  BZ    012A
0110:  MOVLW  06
0112:  MOVWF  01
0114:  CLRF   00
0116:  DECFSZ 00,F
0118:  BRA    0116
011A:  DECFSZ 01,F
011C:  BRA    0114
011E:  MOVLW  7B
0120:  MOVWF  00
0122:  DECFSZ 00,F
0124:  BRA    0122
0126:  DECFSZ FEF,F
0128:  BRA    0110
012A:  GOTO   013A (RETURN)
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, parity=N, bits=8) 
*
00F2:  BTFSS  F9E.4
00F4:  BRA    00F2
00F6:  MOVWF  FAD
00F8:  RETLW  00
.................... #fuses HS,NOWDT,NOLVP,PUT,NOPROTECT 
....................  
....................  
.................... //**************************************************************************** 
.................... //                                BIOS 
.................... //**************************************************************************** 
.................... //****************************  ENTRADAS  ************************************ 
....................  
....................  
.................... //*****************************  SAÍDAS  ************************************* 
.................... #define  led       port_d,7 
....................  
.................... //**************************************************************************** 
.................... //                        CONSTANTES E VARIÁVEIS 
.................... //**************************************************************************** 
.................... int8  usart_rx_buffer[1]; //Buffer de recebimento da usart 
.................... int1  trata_serial_flag; 
....................  
....................  
.................... //*************************************************************************** 
.................... //                               DRIVES 
.................... //*************************************************************************** 
.................... #include <usart18.h> 
.................... //************************************************************************ 
.................... //             DRIVE PARA O HARDWARE DA USART INTERNA - PIC18 
.................... //                            ATZ:29.10.17 
.................... //                           AUTOR: LEANDRO 
.................... //************************************************************************ 
.................... //*************************************************************************** 
.................... //       CHECA SE OCORREU ERRO NO RECEBIMENTO DO BYTE NA USART 
.................... //*************************************************************************** 
.................... //A FUNÇÃO RETORNA: 
.................... //    0 SE A USART NÃO RECEBEU UM NOVO DADO 
.................... //    1 SE A USART RECEBEU UM NOVO DADO E CARREGA EM usart_rx_dado 
.................... //    2 PARA ERRO DE FRAME 
.................... //    3 PARA ERRO DE OVERRUN (BUFFER OVERLOAD) 
....................  
.................... int usart_error(){ 
....................    if (ferr==1){ 
*
0096:  BTFSS  FAB.2
0098:  BRA    00A2
....................    return 1; //erro de frame (stop bit não recebido ou fora de hora) 
009A:  MOVLW  01
009C:  MOVWF  01
009E:  BRA    00C2
....................    ferr=0; 
00A0:  BCF    FAB.2
....................    } 
....................    if (oerr==1){ 
00A2:  BTFSS  FAB.1
00A4:  BRA    00AE
....................    return 3; //erro de overrun (três caracteres foram recebidos pela usart sem ser lidos pela CPU) 
00A6:  MOVLW  03
00A8:  MOVWF  01
00AA:  BRA    00C2
....................    oerr=0; 
00AC:  BCF    FAB.1
....................    } 
....................    if (rcif==0) return 0; 
00AE:  BTFSC  F9E.5
00B0:  BRA    00B8
00B2:  MOVLW  00
00B4:  MOVWF  01
00B6:  BRA    00C2
....................    if (rcif==1) return 1; 
00B8:  BTFSS  F9E.5
00BA:  BRA    00C2
00BC:  MOVLW  01
00BE:  MOVWF  01
00C0:  BRA    00C2
....................     
.................... } 
00C2:  GOTO   00D8 (RETURN)
....................  
....................  
.................... //*************************************************************************** 
.................... //        CHECA SE UM DADO FOI TOTALMENTE TRANSMITIDO PELA USART 
.................... //*************************************************************************** 
.................... //Retorna TRUE se todos os bytes já foram transmitidos ou FALSE se 
.................... //ainda existem bytes no registrador de deslocamento 
.................... short int tx_usart_complete(){ 
.................... return(trmt); 
*
00FA:  MOVLW  00
00FC:  BTFSC  FAC.1
00FE:  MOVLW  01
0100:  MOVWF  01
.................... } 
0102:  GOTO   0130 (RETURN)
....................  
....................  
.................... //************************************************************************** 
.................... //                      DETECÇÃO DE INTERRUPÇÃO 
.................... //************************************************************************** 
.................... short int interrupt_rx_usart(){ 
....................    return(rcif); 
.................... } 
....................  
.................... //*************************************************************************** 
.................... //                            FIM DO INCLUDE 
.................... //*************************************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //**************************************************************************** 
.................... //                       Rotinas da interrupcao 
.................... //**************************************************************************** 
.................... //#inline                     //descomentar se for usar o in_line 
....................  
.................... recebe_dado_usart(){ 
....................   usart_rx_buffer[0] = getc(); 
*
00C6:  BTFSS  F9E.5
00C8:  BRA    00C6
00CA:  MOVFF  FAE,18
....................   trata_serial_flag = true; 
00CE:  BSF    19.0
.................... } 
00D0:  GOTO   00EA (RETURN)
....................  
.................... //**************************************************************************** 
.................... //                           INTERRUPÇÕES 
.................... //**************************************************************************** 
.................... #int_rda 
.................... void rda_isr(void)  
.................... { 
.................... disable_interrupts(int_rda); 
00D4:  BCF    F9D.5
....................    switch(usart_error()){ 
00D6:  BRA    0096
00D8:  MOVF   01,W
00DA:  XORLW  02
00DC:  BZ    00E4
00DE:  XORLW  01
00E0:  BZ    00E6
00E2:  BRA    00E8
....................    case 2: //ERRO DE FRAME 
....................    //Trata erro 
....................    break; 
00E4:  BRA    00EA
....................    case 3: //ERRO DE OVERRUN (BUFFER OVERLOAD) 
....................    //Trata erro 
....................    break; 
00E6:  BRA    00EA
....................    default: //Recebeu um novo dado 
....................    recebe_dado_usart(); 
00E8:  BRA    00C6
....................    } 
.................... enable_interrupts(int_rda); 
00EA:  BSF    F9D.5
.................... } 
....................  
....................  
.................... //*************************************************************************** 
.................... //                          FIM DA INTERRUPCAO 
.................... //*************************************************************************** 
....................  
.................... //**************************************************************************** 
.................... //                             Sub-rotinas 
.................... //**************************************************************************** 
00EC:  BCF    F9E.5
00EE:  GOTO   0054
.................... trata_dado_serial(){     
....................    if (usart_rx_buffer[0] == 's'){ 
*
013E:  MOVF   18,W
0140:  SUBLW  73
0142:  BNZ   0146
....................       bit_set(led); 
0144:  BSF    F83.7
....................    } 
.................... trata_serial_flag = false; 
0146:  BCF    19.0
.................... } 
0148:  GOTO   01CC (RETURN)
....................  
.................... aguarda_transmissao(){ 
....................    while(tx_usart_complete() == true){ 
*
012E:  BRA    00FA
0130:  DECFSZ 01,W
0132:  BRA    013C
....................    delay_ms(1); 
0134:  MOVLW  01
0136:  MOVWF  1A
0138:  BRA    0106
....................    } 
013A:  BRA    012E
.................... } 
013C:  RETLW  00
.................... //**************************************************************************** 
.................... //                          Rotina Principal 
.................... //**************************************************************************** 
....................  
.................... void main(){ 
*
014C:  CLRF   FF8
014E:  BCF    FD0.7
0150:  BSF    07.7
0152:  CLRF   FEA
0154:  CLRF   FE9
0156:  BSF    FB8.3
0158:  MOVLW  08
015A:  MOVWF  FAF
015C:  MOVLW  02
015E:  MOVWF  FB0
0160:  MOVLW  A6
0162:  MOVWF  FAC
0164:  MOVLW  90
0166:  MOVWF  FAB
0168:  NOP   
016A:  NOP   
016C:  MOVF   FC1,W
016E:  ANDLW  C0
0170:  IORLW  0F
0172:  MOVWF  FC1
0174:  MOVLW  07
0176:  MOVWF  FB4
0178:  CLRF   16
017A:  CLRF   17
.................... //********************** CONFIGURAÇÕES INICIAIS ***************************** 
....................       setup_timer_0(rtcc_internal); //clock interno 
017C:  MOVLW  80
017E:  MOVWF  FD5
....................       setup_timer_1(t1_internal|t1_div_by_8);  
0180:  MOVLW  B5
0182:  MOVWF  FCD
....................       setup_wdt(wdt_off); 
0184:  BCF    FD1.0
....................       port_b_pullups(false);    //sem pull-up 
0186:  BSF    FF1.7
....................  
.................... //    Configuração do tris 
.................... //    Bit porta: 76543210 
....................       tris_a = 0b00000000; 
0188:  CLRF   F92
....................       tris_b = 0b00000000; 
018A:  CLRF   F93
....................       tris_c = 0b10000000; 
018C:  MOVLW  80
018E:  MOVWF  F94
....................       tris_d = 0b00000000; 
0190:  CLRF   F95
....................       tris_e = 0b00000000; 
0192:  CLRF   F96
....................        
....................       enable_interrupts(global); 
0194:  MOVLW  C0
0196:  IORWF  FF2,F
....................       enable_interrupts(int_rda); 
0198:  BSF    F9D.5
....................  
.................... //******************** INICIALIZAÇÃO DE VARIÁVEIS *************************** 
....................       trata_serial_flag = false; 
019A:  BCF    19.0
.................... //**************************************************************************** 
....................       putc('L');  //Transmite um byte pela usart 
019C:  MOVLW  4C
019E:  RCALL  00F2
....................       aguarda_transmissao(); 
01A0:  RCALL  012E
....................       putc('e');  //Transmite um byte pela usart 
01A2:  MOVLW  65
01A4:  RCALL  00F2
....................       aguarda_transmissao(); 
01A6:  RCALL  012E
....................       putc('a');  //Transmite um byte pela usart 
01A8:  MOVLW  61
01AA:  RCALL  00F2
....................       aguarda_transmissao(); 
01AC:  RCALL  012E
....................       putc('n');  //Transmite um byte pela usart 
01AE:  MOVLW  6E
01B0:  RCALL  00F2
....................       aguarda_transmissao(); 
01B2:  RCALL  012E
....................       putc('d');  //Transmite um byte pela usart 
01B4:  MOVLW  64
01B6:  RCALL  00F2
....................       aguarda_transmissao(); 
01B8:  RCALL  012E
....................       putc('r');  //Transmite um byte pela usart 
01BA:  MOVLW  72
01BC:  RCALL  00F2
....................       aguarda_transmissao(); 
01BE:  RCALL  012E
....................       putc('o');  //Transmite um byte pela usart 
01C0:  MOVLW  6F
01C2:  RCALL  00F2
....................       aguarda_transmissao(); 
01C4:  RCALL  012E
....................        
.................... //**************************************************************************** 
.................... //                             INICIO DO LOOP 
.................... //**************************************************************************** 
....................       while(1){   
....................       restart_wdt(); 
01C6:  CLRWDT
....................       if (trata_serial_flag = true) trata_dado_serial(); 
01C8:  BSF    19.0
01CA:  BRA    013E
....................       } 
01CC:  BRA    01C6
.................... //********************************* FIM ************************************** 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
01CE:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS IESO FCMEN
   Word  2: 1E1E   BROWNOUT NOWDT BORV20 PUT WDT32768
   Word  3: 8700   PBADEN CCP2C1 LPT1OSC MCLR
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
