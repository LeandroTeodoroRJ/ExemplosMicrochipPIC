CCS PCM C Compiler, Version 4.104, 5967               24-set-17 07:31

               Filename: C:\DADOS\projeto\MicrochipPicDisplay7Segmentos\main.lst

               ROM used: 181 words (2%)
                         Largest free fragment is 2048
               RAM used: 16 (4%) at main() level
                         19 (5%) worst case
               Stack:    2 worst case (0 in main + 2 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   07F
0003:  NOP
.................... //**************************************************************************** 
.................... //                   EXEMPLO DISPLAYS DE 7 SEGMENTOS 
.................... //**************************************************************************** 
.................... //Compilador CCS PCWH Ver 4.104 
....................  
.................... #include <16F877.h>              //include do 16F628 
.................... //////// Standard Header file for the PIC16F877 device //////////////// 
.................... #device PIC16F877 
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0088:  BCF    03.5
0089:  CLRF   20
008A:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <16f8x_registradores.h>//MAPEAMENTO DE MEÓRIA DOS REGISTRADORES 
.................... //********************************************************** 
.................... //INCLUDE DE MAPEAMENTO DE MEÓRIA DOS REGISTRADORES 
.................... //ESPECIAIS E BITS DOS MESMOS PARA OS mC 16f87X 
.................... //********************************************************** 
....................  
.................... #byte option_reg = 0x81 
.................... #byte status = 0x03 
.................... #byte tris_a = 0x85        //#byte - define o endereco do 
.................... #byte tris_b = 0x86        //registrador no banco de memoria 
.................... #byte tris_c = 0x87        //de acordo com o datasheet 
.................... #byte tris_d = 0x88        //de acordo com o datasheet 
.................... #byte tris_e = 0x89        //de acordo com o datasheet 
.................... #byte port_a = 0x05 
.................... #byte port_b = 0x06 
.................... #byte port_c = 0x07 
.................... #byte port_d = 0x08 
.................... #byte port_e = 0x09 
.................... #byte intcon = 0x0b 
....................  
.................... //USART 
.................... #byte txsta = 0x98 
.................... #byte rcsta = 0x18 
.................... #byte spbrg = 0x99 
.................... #byte txreg = 0x19 
.................... #byte rcreg = 0x1a    
....................  
.................... #byte pir1 = 0x0c 
.................... #byte pie1 = 0x8c 
....................  
.................... //registrador pie1 
.................... #bit  eeie   = pie1.7 
.................... #bit  cmie   = pie1.6 
.................... #bit  rcie   = pie1.5 
.................... #bit  txie   = pie1.4 
.................... #bit  ccp1ie = pie1.2 
.................... #bit  tmr2ie = pie1.1 
.................... #bit  tmr1ie = pie1.0 
....................  
.................... //registrador pir1 
.................... #bit  eeif   = pir1.7 
.................... #bit  cmif   = pir1.6 
.................... #bit  rcif   = pir1.5 
.................... #bit  txif   = pir1.4 
.................... #bit  ccp1if = pir1.2 
.................... #bit  tmr2if = pir1.1 
.................... #bit  tmr1if = pir1.0 
....................  
.................... //registrador txsta 
.................... #bit  csrc  = txsta.7 
.................... #bit  tx9   = txsta.6 
.................... #bit  txen  = txsta.5 
.................... #bit  sync  = txsta.4 
.................... #bit  brgh =  txsta.2 
.................... #bit  trmt =  txsta.1 
.................... #bit  tx9d =  txsta.0 
....................  
.................... //registrador rcsta 
.................... #bit  spen  = rcsta.7 
.................... #bit  rx9   = rcsta.6 
.................... #bit  sren  = rcsta.5 
.................... #bit  cren  = rcsta.4 
.................... #bit  adden = rcsta.3 
.................... #bit  ferr  = rcsta.2 
.................... #bit  oerr  = rcsta.1 
.................... #bit  rx9d  = rcsta.0 
....................  
....................  
.................... //registrador intcon 
.................... #bit  gie = 0x0b.7 
.................... #bit  peie = 0x0b.6 
.................... #bit  t0ie = 0x0b.5 
.................... #bit  inte = 0x0b.4 
.................... #bit  rbie = 0x0b.3 
.................... #bit  t0if = 0x0b.2 
.................... #bit  intf = 0x0b.1 
.................... #bit  rbif = 0x0b.0 
....................  
.................... #bit  trigger = port_b.3 
.................... #bit  trigger_inv =  port_b.4 
....................  
....................                                                      
....................  
.................... //**************************************************************************** 
.................... //                    CONFIGURAÇÕES DO COMPILADOR 
.................... //**************************************************************************** 
....................  
.................... #use fast_io(a)                  //modo de entrada e saida de dados que 
.................... #use fast_io(b)                  //o compilador nao configura o tris 
....................  
.................... #use delay(clock=20000000)        //clock usual 
.................... #fuses HS,NOWDT,NOLVP,PUT,NOPROTECT 
....................  
....................  
.................... //**************************************************************************** 
.................... //                                BIOS 
.................... //**************************************************************************** 
.................... //****************************  ENTRADAS  ************************************ 
....................  
....................  
.................... //*****************************  SAÍDAS  ************************************* 
.................... #define  DISPLAY_BUS    port_b 
.................... #define  DISPLAY_A      0 
.................... #define  DISPLAY_B      1 
.................... #define  DISPLAY_C      2 
.................... #define  DISPLAY_D      3 
.................... #define  DISPLAY_COM    port_c 
.................... #define  PONTO          port_b,7 
....................  
.................... //**************************************************************************** 
.................... //                        CONSTANTES E VARIÁVEIS 
.................... //**************************************************************************** 
.................... int   w_temp; 
.................... int   status_temp; 
.................... long int   count; 
.................... unsigned long int   count_timer1; 
.................... int   count_disp_control; 
.................... int   count_disp; 
.................... const int   CONV_DISP[25]={                    
....................                    0b00111111, 
....................                    0b00000110, 
....................                    0b01011011, 
....................                    0b01001111, 
....................                    0b01100110, 
....................                    0b01101101, 
....................                    0b01111100, 
....................                    0b00000111, 
....................                    0b01111111, 
....................                    0b01101111, 
....................                    0b01110111, 
....................                    0b00111001, 
....................                    0b01011110, 
....................                    0b01111001, 
....................                    0b01110001, 
....................                    0b01111101, 
....................                    0b01110110, 
....................                    0b00011110, 
....................                    0b00111000, 
....................                    0b01010100, 
....................                    0b01011100, 
....................                    0b01110011, 
....................                    0b01010000, 
....................                    0b01111000, 
....................                    0b00011100 
....................                            }; 
.................... /* 
....................       //Conversão para o display de 7 segmentos 
....................       //      LEDS:  PGFEDCBA        Onde P=ponto 
....................       CONV_DISP[0]=0b00111111; //0 
....................       CONV_DISP[1]=0b00000110; //1 
....................       CONV_DISP[2]=0b01011011; //2 
....................       CONV_DISP[3]=0b01001111; //3 
....................       CONV_DISP[4]=0b01100110; //4 
....................       CONV_DISP[5]=0b01101101; //5 
....................       CONV_DISP[6]=0b01111100; //6 
....................       CONV_DISP[7]=0b00000111; //7 
....................       CONV_DISP[8]=0b01111111; //8 
....................       CONV_DISP[9]=0b01101111; //9 
....................      CONV_DISP[10]=0b01110111; //A 
....................      CONV_DISP[11]=0b00111001; //C 
....................      CONV_DISP[12]=0b01011110; //d 
....................      CONV_DISP[13]=0b01111001; //E 
....................      CONV_DISP[14]=0b01110001; //F 
....................      CONV_DISP[15]=0b01111101; //G 
....................      CONV_DISP[16]=0b01110110; //H 
....................      CONV_DISP[17]=0b00011110; //J 
....................      CONV_DISP[18]=0b00111000; //L 
....................      CONV_DISP[19]=0b01010100; //n 
....................      CONV_DISP[20]=0b01011100; //o 
....................      CONV_DISP[21]=0b01110011; //P 
....................      CONV_DISP[22]=0b01010000; //r 
....................      CONV_DISP[23]=0b01111000; //t 
....................      CONV_DISP[24]=0b00011100; //u 
.................... */ 
....................  
....................  
.................... //*************************************************************************** 
.................... //                               DRIVES 
.................... //*************************************************************************** 
....................  
....................  
.................... //**************************************************************************** 
.................... //                       Rotinas da interrupcao 
.................... //**************************************************************************** 
.................... //#inline                     //descomentar se for usar o in_line 
.................... void mostra_display(int disp, short int dot, int value);     
....................  
.................... void estouro_timer0(){ 
....................    if (count == 50){          //Base de aprox 20ms 
*
000E:  MOVF   24,W
000F:  SUBLW  32
0010:  BTFSS  03.2
0011:  GOTO   03F
0012:  MOVF   25,F
0013:  BTFSS  03.2
0014:  GOTO   03F
....................       mostra_display(count_disp_control, false, count_disp); 
0015:  MOVF   28,W
0016:  MOVWF  2B
0017:  CLRF   2C
0018:  MOVF   29,W
0019:  MOVWF  2D
....................       count_disp_control = count_disp_control+1; 
*
0036:  MOVLW  01
0037:  ADDWF  28,F
....................       if (count_disp_control > 3) count_disp_control = 0; 
0038:  MOVF   28,W
0039:  SUBLW  03
003A:  BTFSS  03.0
003B:  CLRF   28
....................       count = 0; 
003C:  CLRF   25
003D:  CLRF   24
....................    } 
....................    else{ 
003E:  GOTO   043
....................       count = count+1; 
003F:  MOVLW  01
0040:  ADDWF  24,F
0041:  BTFSC  03.0
0042:  INCF   25,F
....................    } 
.................... t0if = false;                //Reseta o flag de interrupção do timer0 
0043:  BCF    0B.2
.................... } 
....................  
.................... void estouro_timer1(){ 
....................    if (count_timer1 == 20){              //Base de aprox 1s. 
*
0046:  MOVF   26,W
0047:  SUBLW  14
0048:  BTFSS  03.2
0049:  GOTO   056
004A:  MOVF   27,F
004B:  BTFSS  03.2
004C:  GOTO   056
....................       count_disp = count_disp+1; 
004D:  MOVLW  01
004E:  ADDWF  29,F
....................          if (count_disp > 24) count_disp = 0; 
004F:  MOVF   29,W
0050:  SUBLW  18
0051:  BTFSS  03.0
0052:  CLRF   29
....................       count_timer1 = 0; 
0053:  CLRF   27
0054:  CLRF   26
....................    } 
....................    else{ 
0055:  GOTO   05A
....................       count_timer1 = count_timer1+1;  
0056:  MOVLW  01
0057:  ADDWF  26,F
0058:  BTFSC  03.0
0059:  INCF   27,F
....................    } 
.................... tmr1if = false;           //Reseta o flag de interrupção do timer1 
005A:  BCF    0C.0
.................... } 
.................... //**************************************************************************** 
.................... //                           INTERRUPÇÕES 
.................... //**************************************************************************** 
.................... #int_global 
.................... void interrupcao(){ 
.................... restart_wdt(); 
*
0004:  CLRWDT
.................... disable_interrupts(global); 
0005:  BCF    0B.6
0006:  BCF    0B.7
0007:  BTFSC  0B.7
0008:  GOTO   006
....................  
.................... #asm 
.................... movwf w_temp 
0009:  MOVWF  22
.................... swapf status,w 
000A:  SWAPF  03,W
.................... movwf status_temp 
000B:  MOVWF  23
.................... #endasm 
....................  
.................... if (intcon,t0if == true) estouro_timer0(); //Trata interrupção timer0 
000C:  BTFSS  0B.2
000D:  GOTO   044
.................... if (pir1,tmr1if == true) estouro_timer1(); //Trata interrupção timer1 
*
0044:  BTFSS  0C.0
0045:  GOTO   05B
....................  
.................... //*************************************************************************** 
.................... //                          FIM DA INTERRUPCAO 
.................... //*************************************************************************** 
.................... enable_interrupts(global); 
*
005B:  MOVLW  C0
005C:  IORWF  0B,F
....................  
.................... #asm 
.................... swapf status_temp,w 
005D:  SWAPF  23,W
.................... movwf status 
005E:  MOVWF  03
.................... swapf w_temp,f 
005F:  SWAPF  22,F
.................... swapf w_temp,w 
0060:  SWAPF  22,W
0061:  RETFIE
.................... #endasm 
....................  
.................... } 
....................  
.................... //**************************************************************************** 
.................... //                             Sub-rotinas 
.................... //**************************************************************************** 
.................... void mostra_display(int disp, short int dot, int value){     
.................... DISPLAY_BUS = CONV_DISP[value]; 
*
001A:  MOVF   2D,W
001B:  CALL   062
001C:  MOVWF  78
001D:  MOVWF  06
.................... if (dot == true) bit_set(PONTO); 
001E:  DECFSZ 2C,W
001F:  GOTO   021
0020:  BSF    06.7
.................... if (dot==true){ 
0021:  DECFSZ 2C,W
0022:  GOTO   025
....................    bit_set(PONTO); 
0023:  BSF    06.7
.................... } 
.................... else{ 
0024:  GOTO   026
....................    bit_clear(PONTO); 
0025:  BCF    06.7
.................... } 
.................... bit_clear(DISPLAY_COM,DISPLAY_A); 
0026:  BCF    07.0
.................... bit_clear(DISPLAY_COM,DISPLAY_B); 
0027:  BCF    07.1
.................... bit_clear(DISPLAY_COM,DISPLAY_C); 
0028:  BCF    07.2
.................... bit_clear(DISPLAY_COM,DISPLAY_D); 
0029:  BCF    07.3
.................... bit_set(DISPLAY_COM,disp); 
002A:  MOVLW  01
002B:  MOVWF  77
002C:  MOVF   2B,W
002D:  MOVWF  78
002E:  BTFSC  03.2
002F:  GOTO   034
0030:  BCF    03.0
0031:  RLF    77,F
0032:  DECFSZ 78,F
0033:  GOTO   030
0034:  MOVF   77,W
0035:  IORWF  07,F
.................... } 
....................  
....................  
.................... //**************************************************************************** 
.................... //                          Rotina Principal 
.................... //**************************************************************************** 
....................  
.................... void main(){ 
*
007F:  CLRF   04
0080:  BCF    03.7
0081:  MOVLW  1F
0082:  ANDWF  03,F
0083:  BSF    03.5
0084:  BSF    1F.0
0085:  BSF    1F.1
0086:  BSF    1F.2
0087:  BCF    1F.3
.................... //********************** CONFIGURAÇÕES INICIAIS ***************************** 
....................       setup_timer_0(rtcc_internal); //clock interno 
*
008D:  BSF    03.5
008E:  MOVF   01,W
008F:  ANDLW  C0
0090:  MOVWF  01
....................       setup_timer_1(t1_internal|t1_div_by_8);  
0091:  MOVLW  B5
0092:  BCF    03.5
0093:  MOVWF  10
.................... //      setup_wdt(wdt_288ms); 
....................       setup_ccp1(ccp_off); //Desliga os modos de captura 
0094:  BSF    2A.2
0095:  MOVF   2A,W
0096:  BSF    03.5
0097:  MOVWF  07
0098:  BCF    03.5
0099:  CLRF   17
....................       setup_ccp2(ccp_off); 
009A:  BSF    2A.1
009B:  MOVF   2A,W
009C:  BSF    03.5
009D:  MOVWF  07
009E:  BCF    03.5
009F:  CLRF   1D
....................       enable_interrupts(global); 
00A0:  MOVLW  C0
00A1:  IORWF  0B,F
....................       enable_interrupts(int_timer0); 
00A2:  BSF    0B.5
....................       enable_interrupts(int_timer1); 
00A3:  BSF    03.5
00A4:  BSF    0C.0
....................       port_b_pullups(false);    //sem pull-up 
00A5:  BSF    01.7
....................  
.................... //    Configuração do tris 
.................... //    Bit porta: 76543210 
....................       tris_a = 0b00000000; 
00A6:  CLRF   05
....................       tris_b = 0b00000000; 
00A7:  CLRF   06
....................       tris_c = 0b00000000; 
00A8:  CLRF   07
....................       tris_d = 0b00000000; 
00A9:  CLRF   08
....................       tris_e = 0b00000000; 
00AA:  CLRF   09
....................        
....................        
.................... //******************** INICIALIZAÇÃO DE VARIÁVEIS *************************** 
....................       count = 0; 
00AB:  BCF    03.5
00AC:  CLRF   25
00AD:  CLRF   24
....................       count_timer1 = 0; 
00AE:  CLRF   27
00AF:  CLRF   26
....................       count_disp_control = 0; 
00B0:  CLRF   28
....................       count_disp = 0; 
00B1:  CLRF   29
....................        
.................... //**************************************************************************** 
.................... //                             INICIO DO LOOP 
.................... //**************************************************************************** 
....................       while(1){   
....................       restart_wdt(); 
00B2:  CLRWDT
....................        
....................       } 
00B3:  GOTO   0B2
.................... //********************************* FIM ************************************** 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
00B4:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT NOPROTECT BROWNOUT NOLVP NOCPD NOWRT NODEBUG
