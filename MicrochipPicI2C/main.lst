CCS PCM C Compiler, Version 4.104, 5967               20-set-17 18:38

               Filename: C:\DADOS\projeto\MicrochipPicI2C\main.lst

               ROM used: 423 words (5%)
                         Largest free fragment is 2048
               RAM used: 10 (3%) at main() level
                         13 (4%) worst case
               Stack:    2 worst case (1 in main + 1 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   0BA
0003:  NOP
.................... //**************************************************************************** 
.................... //              EXEMPLO INTERFACE I2C COM MEMÓRIA EEPROM SERIAL 
.................... //**************************************************************************** 
.................... //Compilador CCS PCWH Ver 4.104 
.................... //**************************************************************************** 
.................... /* 
.................... OBS:  
.................... O primeiro byte enviado para a memória 24C02 segue a seguinte lógica: 
.................... BITS: |7|6|5|4|3|2|1|0| 
....................       |1|0|1|0|R|S|T|U| 
....................       Onde: 
....................       R,S,T são os níveis lógicos de A2,A1 e A0 respectivamente 
....................       U -> 0 para escrita e 1 para leitura 
.................... */ 
.................... //**************************************************************************** 
....................  
.................... #include <16F877.h>              //include do 16F628 
.................... //////// Standard Header file for the PIC16F877 device //////////////// 
.................... #device PIC16F877 
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
00C3:  BCF    03.5
00C4:  CLRF   20
00C5:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <16f8x_registradores.h>//MAPEAMENTO DE MEÓRIA DOS REGISTRADORES 
.................... //********************************************************** 
.................... //INCLUDE DE MAPEAMENTO DE MEÓRIA DOS REGISTRADORES 
.................... //ESPECIAIS E BITS DOS MESMOS PARA OS mC 16f87X 
.................... //********************************************************** 
....................  
.................... #byte option_reg = 0x81 
.................... #byte status = 0x03 
.................... #byte tris_a = 0x85        //#byte - define o endereco do 
.................... #byte tris_b = 0x86        //registrador no banco de memoria 
.................... #byte tris_c = 0x87        //de acordo com o datasheet 
.................... #byte tris_d = 0x88        //de acordo com o datasheet 
.................... #byte tris_e = 0x89        //de acordo com o datasheet 
.................... #byte port_a = 0x05 
.................... #byte port_b = 0x06 
.................... #byte port_c = 0x07 
.................... #byte port_d = 0x08 
.................... #byte port_e = 0x09 
.................... #byte intcon = 0x0b 
....................  
.................... //USART 
.................... #byte txsta = 0x98 
.................... #byte rcsta = 0x18 
.................... #byte spbrg = 0x99 
.................... #byte txreg = 0x19 
.................... #byte rcreg = 0x1a    
....................  
.................... #byte pir1 = 0x0c 
.................... #byte pie1 = 0x8c 
....................  
.................... //registrador pie1 
.................... #bit  eeie   = pie1.7 
.................... #bit  cmie   = pie1.6 
.................... #bit  rcie   = pie1.5 
.................... #bit  txie   = pie1.4 
.................... #bit  ccp1ie = pie1.2 
.................... #bit  tmr2ie = pie1.1 
.................... #bit  tmr1ie = pie1.0 
....................  
.................... //registrador pir1 
.................... #bit  eeif   = pir1.7 
.................... #bit  cmif   = pir1.6 
.................... #bit  rcif   = pir1.5 
.................... #bit  txif   = pir1.4 
.................... #bit  ccp1if = pir1.2 
.................... #bit  tmr2if = pir1.1 
.................... #bit  tmr1if = pir1.0 
....................  
.................... //registrador txsta 
.................... #bit  csrc  = txsta.7 
.................... #bit  tx9   = txsta.6 
.................... #bit  txen  = txsta.5 
.................... #bit  sync  = txsta.4 
.................... #bit  brgh =  txsta.2 
.................... #bit  trmt =  txsta.1 
.................... #bit  tx9d =  txsta.0 
....................  
.................... //registrador rcsta 
.................... #bit  spen  = rcsta.7 
.................... #bit  rx9   = rcsta.6 
.................... #bit  sren  = rcsta.5 
.................... #bit  cren  = rcsta.4 
.................... #bit  adden = rcsta.3 
.................... #bit  ferr  = rcsta.2 
.................... #bit  oerr  = rcsta.1 
.................... #bit  rx9d  = rcsta.0 
....................  
....................  
.................... //registrador intcon 
.................... #bit  gie = 0x0b.7 
.................... #bit  peie = 0x0b.6 
.................... #bit  t0ie = 0x0b.5 
.................... #bit  inte = 0x0b.4 
.................... #bit  rbie = 0x0b.3 
.................... #bit  t0if = 0x0b.2 
.................... #bit  intf = 0x0b.1 
.................... #bit  rbif = 0x0b.0 
....................  
.................... #bit  trigger = port_b.3 
.................... #bit  trigger_inv =  port_b.4 
....................  
....................  
....................                                                      
.................... //**************************************************************************** 
.................... //                    CONFIGURAÇÕES DO COMPILADOR 
.................... //**************************************************************************** 
.................... #use fast_io(a)                  //modo de entrada e saida de dados que 
.................... #use fast_io(b)                  //o compilador nao configura o tris 
.................... #use i2c (master, sda=PIN_C4, scl=PIN_C3,fast=100000)   //Habilita o i2c com velocidade de 100KHz 
*
0013:  MOVLW  08
0014:  MOVWF  78
0015:  NOP
0016:  BCF    07.3
0017:  BCF    22.3
0018:  MOVF   22,W
0019:  BSF    03.5
001A:  MOVWF  07
001B:  NOP
001C:  BCF    03.5
001D:  RLF    25,F
001E:  BCF    07.4
001F:  BTFSS  03.0
0020:  GOTO   027
0021:  BSF    22.4
0022:  MOVF   22,W
0023:  BSF    03.5
0024:  MOVWF  07
0025:  GOTO   02B
0026:  BCF    03.5
0027:  BCF    22.4
0028:  MOVF   22,W
0029:  BSF    03.5
002A:  MOVWF  07
002B:  NOP
002C:  BCF    03.5
002D:  BSF    22.3
002E:  MOVF   22,W
002F:  BSF    03.5
0030:  MOVWF  07
0031:  BCF    03.5
0032:  BTFSS  07.3
0033:  GOTO   032
0034:  DECFSZ 78,F
0035:  GOTO   015
0036:  NOP
0037:  BCF    07.3
0038:  BCF    22.3
0039:  MOVF   22,W
003A:  BSF    03.5
003B:  MOVWF  07
003C:  NOP
003D:  BCF    03.5
003E:  BSF    22.4
003F:  MOVF   22,W
0040:  BSF    03.5
0041:  MOVWF  07
0042:  NOP
0043:  NOP
0044:  BCF    03.5
0045:  BSF    22.3
0046:  MOVF   22,W
0047:  BSF    03.5
0048:  MOVWF  07
0049:  BCF    03.5
004A:  BTFSS  07.3
004B:  GOTO   04A
004C:  CLRF   78
004D:  NOP
004E:  BTFSC  07.4
004F:  BSF    78.0
0050:  BCF    07.3
0051:  BCF    22.3
0052:  MOVF   22,W
0053:  BSF    03.5
0054:  MOVWF  07
0055:  BCF    03.5
0056:  BCF    07.4
0057:  BCF    22.4
0058:  MOVF   22,W
0059:  BSF    03.5
005A:  MOVWF  07
005B:  BCF    03.5
005C:  RETURN
*
0073:  MOVLW  08
0074:  MOVWF  26
0075:  MOVF   77,W
0076:  MOVWF  27
0077:  BSF    22.4
0078:  MOVF   22,W
0079:  BSF    03.5
007A:  MOVWF  07
007B:  NOP
007C:  BCF    03.5
007D:  BSF    22.3
007E:  MOVF   22,W
007F:  BSF    03.5
0080:  MOVWF  07
0081:  BCF    03.5
0082:  BTFSS  07.3
0083:  GOTO   082
0084:  BTFSC  07.4
0085:  BSF    03.0
0086:  BTFSS  07.4
0087:  BCF    03.0
0088:  RLF    78,F
0089:  NOP
008A:  BCF    22.3
008B:  MOVF   22,W
008C:  BSF    03.5
008D:  MOVWF  07
008E:  BCF    03.5
008F:  BCF    07.3
0090:  DECFSZ 26,F
0091:  GOTO   077
0092:  BSF    22.4
0093:  MOVF   22,W
0094:  BSF    03.5
0095:  MOVWF  07
0096:  NOP
0097:  BCF    03.5
0098:  BCF    07.4
0099:  MOVF   27,W
009A:  BTFSC  03.2
009B:  GOTO   0A1
009C:  BCF    22.4
009D:  MOVF   22,W
009E:  BSF    03.5
009F:  MOVWF  07
00A0:  BCF    03.5
00A1:  NOP
00A2:  BSF    22.3
00A3:  MOVF   22,W
00A4:  BSF    03.5
00A5:  MOVWF  07
00A6:  BCF    03.5
00A7:  BTFSS  07.3
00A8:  GOTO   0A7
00A9:  NOP
00AA:  BCF    07.3
00AB:  BCF    22.3
00AC:  MOVF   22,W
00AD:  BSF    03.5
00AE:  MOVWF  07
00AF:  NOP
00B0:  BCF    03.5
00B1:  BCF    07.4
00B2:  BCF    22.4
00B3:  MOVF   22,W
00B4:  BSF    03.5
00B5:  MOVWF  07
00B6:  BCF    03.5
00B7:  BCF    0A.3
00B8:  BCF    0A.4
00B9:  GOTO   187 (RETURN)
....................  
.................... #use delay(clock=20000000)        //clock usual 
*
005D:  MOVLW  25
005E:  MOVWF  04
005F:  BCF    03.7
0060:  MOVF   00,W
0061:  BTFSC  03.2
0062:  GOTO   070
0063:  MOVLW  06
0064:  MOVWF  78
0065:  CLRF   77
0066:  DECFSZ 77,F
0067:  GOTO   066
0068:  DECFSZ 78,F
0069:  GOTO   065
006A:  MOVLW  7B
006B:  MOVWF  77
006C:  DECFSZ 77,F
006D:  GOTO   06C
006E:  DECFSZ 00,F
006F:  GOTO   063
0070:  BCF    0A.3
0071:  BCF    0A.4
0072:  GOTO   136 (RETURN)
.................... #fuses HS,NOWDT,NOLVP,PUT,NOPROTECT 
....................  
.................... //**************************************************************************** 
.................... //                                BIOS 
.................... //**************************************************************************** 
.................... //****************************  ENTRADAS  ************************************ 
....................  
.................... //*****************************  SAÍDAS  ************************************* 
.................... #define  saida       port_d 
....................  
.................... //**************************************************************************** 
.................... //                        CONSTANTES E VARIÁVEIS 
.................... //**************************************************************************** 
.................... #define  DADO                 0b11110000 
.................... #define  EEPROM_ADRESS_WRITE  0b10100000 
.................... #define  EEPROM_ADRESS_READ   0b10100001 
.................... #define  ENDERECO_INTERNO     0x05 
....................  
.................... int   w_temp; 
.................... int   status_temp; 
....................  
.................... //*************************************************************************** 
.................... //                               DRIVES 
.................... //*************************************************************************** 
.................... //#include <usart.h> 
....................  
....................  
....................  
.................... //**************************************************************************** 
.................... //                       Rotinas da interrupcao 
.................... //**************************************************************************** 
.................... //#inline                     //descomentar se for usar o in_line 
....................  
....................  
....................  
.................... //**************************************************************************** 
.................... //                           INTERRUPÇÕES 
.................... //**************************************************************************** 
.................... #int_global 
.................... void interrupcao(){ 
.................... restart_wdt(); 
*
0004:  CLRWDT
.................... disable_interrupts(global); 
0005:  BCF    0B.6
0006:  BCF    0B.7
0007:  BTFSC  0B.7
0008:  GOTO   006
.................... #asm 
.................... movwf w_temp 
0009:  MOVWF  23
.................... swapf status,w 
000A:  SWAPF  03,W
.................... movwf status_temp 
000B:  MOVWF  24
.................... #endasm 
....................  
....................  
.................... //*************************************************************************** 
.................... //                          FIM DA INTERRUPCAO 
.................... //*************************************************************************** 
.................... enable_interrupts(global); 
000C:  MOVLW  C0
000D:  IORWF  0B,F
.................... #asm 
.................... swapf status_temp,w 
000E:  SWAPF  24,W
.................... movwf status 
000F:  MOVWF  03
.................... swapf w_temp,f 
0010:  SWAPF  23,F
.................... swapf w_temp,w 
0011:  SWAPF  23,W
0012:  RETFIE
.................... #endasm 
.................... } 
....................  
.................... //**************************************************************************** 
.................... //                             Sub-rotinas 
.................... //**************************************************************************** 
....................  
....................  
.................... //**************************************************************************** 
.................... //                          Rotina Principal 
.................... //**************************************************************************** 
....................  
.................... void main(){ 
*
00BA:  CLRF   04
00BB:  BCF    03.7
00BC:  MOVLW  1F
00BD:  ANDWF  03,F
00BE:  BSF    03.5
00BF:  BSF    1F.0
00C0:  BSF    1F.1
00C1:  BSF    1F.2
00C2:  BCF    1F.3
.................... //********************** CONFIGURAÇÕES INICIAIS ***************************** 
....................       setup_timer_0(rtcc_internal); //clock interno 
*
00C8:  BSF    03.5
00C9:  MOVF   01,W
00CA:  ANDLW  C0
00CB:  MOVWF  01
....................       setup_wdt(wdt_288ms); 
00CC:  MOVLW  0C
00CD:  MOVWF  77
00CE:  BCF    03.5
00CF:  CLRF   01
00D0:  MOVLW  81
00D1:  MOVWF  04
00D2:  BCF    03.7
00D3:  MOVF   00,W
00D4:  ANDLW  F0
00D5:  IORLW  07
00D6:  MOVWF  00
00D7:  CLRWDT
00D8:  MOVF   00,W
00D9:  ANDLW  F7
00DA:  BTFSC  77.3
00DB:  ANDLW  F0
00DC:  IORWF  77,W
00DD:  MOVWF  00
....................       disable_interrupts(global); 
00DE:  BCF    0B.6
00DF:  BCF    0B.7
00E0:  BTFSC  0B.7
00E1:  GOTO   0DF
....................       port_b_pullups(false);    //sem pull-up 
00E2:  BSF    03.5
00E3:  BSF    01.7
....................  
.................... //    Configuração do tris 
.................... //    Bit porta: 76543210 
....................       tris_a = 0b00000000; 
00E4:  CLRF   05
....................       tris_b = 0b00000000; 
00E5:  CLRF   06
....................       tris_c = 0b00000000; 
00E6:  CLRF   07
....................       tris_d = 0b00000000; 
00E7:  CLRF   08
....................       tris_e = 0b00000000; 
00E8:  CLRF   09
....................        
....................        
.................... //******************** INICIALIZAÇÃO DE VARIÁVEIS *************************** 
....................       saida = 0; 
00E9:  BCF    03.5
00EA:  CLRF   08
....................        
.................... //**************************************************************************** 
.................... //                             INICIO DO LOOP 
.................... //**************************************************************************** 
....................       while(1){   
....................       restart_wdt(); 
00EB:  CLRWDT
....................        
....................       //Escrita 24C02 
....................       i2c_start();               //Coloca o barramento em condição de inicializar a comunicação 
00EC:  BSF    22.4
00ED:  MOVF   22,W
00EE:  BSF    03.5
00EF:  MOVWF  07
00F0:  MOVLW  04
00F1:  MOVWF  77
00F2:  DECFSZ 77,F
00F3:  GOTO   0F2
00F4:  BCF    03.5
00F5:  BSF    22.3
00F6:  MOVF   22,W
00F7:  BSF    03.5
00F8:  MOVWF  07
00F9:  MOVLW  03
00FA:  MOVWF  77
00FB:  DECFSZ 77,F
00FC:  GOTO   0FB
00FD:  BCF    03.5
00FE:  BCF    07.4
00FF:  BCF    22.4
0100:  MOVF   22,W
0101:  BSF    03.5
0102:  MOVWF  07
0103:  MOVLW  04
0104:  MOVWF  77
0105:  DECFSZ 77,F
0106:  GOTO   105
0107:  BCF    03.5
0108:  BCF    07.3
0109:  BCF    22.3
010A:  MOVF   22,W
010B:  BSF    03.5
010C:  MOVWF  07
....................       i2c_write(EEPROM_ADRESS_WRITE);       //Endereço do dispositivo (escrita) 
010D:  MOVLW  A0
010E:  BCF    03.5
010F:  MOVWF  25
0110:  CALL   013
....................       i2c_write(ENDERECO_INTERNO);       //Endereço interno da memória para alocação do dado 
0111:  MOVLW  05
0112:  MOVWF  25
0113:  CALL   013
....................       i2c_write(DADO);           //Grava o dado na memória 
0114:  MOVLW  F0
0115:  MOVWF  25
0116:  CALL   013
....................       i2c_stop();                //Finaliza a comunicação com o barramento 
0117:  BCF    22.4
0118:  MOVF   22,W
0119:  BSF    03.5
011A:  MOVWF  07
011B:  NOP
011C:  BCF    03.5
011D:  BSF    22.3
011E:  MOVF   22,W
011F:  BSF    03.5
0120:  MOVWF  07
0121:  BCF    03.5
0122:  BTFSS  07.3
0123:  GOTO   122
0124:  MOVLW  04
0125:  MOVWF  77
0126:  DECFSZ 77,F
0127:  GOTO   126
0128:  GOTO   129
0129:  NOP
012A:  BSF    22.4
012B:  MOVF   22,W
012C:  BSF    03.5
012D:  MOVWF  07
012E:  MOVLW  04
012F:  MOVWF  77
0130:  DECFSZ 77,F
0131:  GOTO   130
....................       delay_ms(11); 
0132:  MOVLW  0B
0133:  BCF    03.5
0134:  MOVWF  25
0135:  GOTO   05D
....................        
....................       //Leitura 24C02 
....................       i2c_start();               //Coloca o barramento em condição de inicializar a comunicação 
0136:  BSF    22.4
0137:  MOVF   22,W
0138:  BSF    03.5
0139:  MOVWF  07
013A:  MOVLW  04
013B:  MOVWF  77
013C:  DECFSZ 77,F
013D:  GOTO   13C
013E:  BCF    03.5
013F:  BSF    22.3
0140:  MOVF   22,W
0141:  BSF    03.5
0142:  MOVWF  07
0143:  MOVLW  03
0144:  MOVWF  77
0145:  DECFSZ 77,F
0146:  GOTO   145
0147:  BCF    03.5
0148:  BCF    07.4
0149:  BCF    22.4
014A:  MOVF   22,W
014B:  BSF    03.5
014C:  MOVWF  07
014D:  MOVLW  04
014E:  MOVWF  77
014F:  DECFSZ 77,F
0150:  GOTO   14F
0151:  BCF    03.5
0152:  BCF    07.3
0153:  BCF    22.3
0154:  MOVF   22,W
0155:  BSF    03.5
0156:  MOVWF  07
....................       i2c_write(EEPROM_ADRESS_WRITE);     //Device select 
0157:  MOVLW  A0
0158:  BCF    03.5
0159:  MOVWF  25
015A:  CALL   013
....................       i2c_write(ENDERECO_INTERNO);     //Endereço interno da memória para leitura do dado 
015B:  MOVLW  05
015C:  MOVWF  25
015D:  CALL   013
....................       i2c_start();               //Faz um restart 
015E:  BSF    22.4
015F:  MOVF   22,W
0160:  BSF    03.5
0161:  MOVWF  07
0162:  MOVLW  04
0163:  MOVWF  77
0164:  DECFSZ 77,F
0165:  GOTO   164
0166:  BCF    03.5
0167:  BSF    22.3
0168:  MOVF   22,W
0169:  BSF    03.5
016A:  MOVWF  07
016B:  MOVLW  03
016C:  MOVWF  77
016D:  DECFSZ 77,F
016E:  GOTO   16D
016F:  BCF    03.5
0170:  BTFSS  07.3
0171:  GOTO   170
0172:  BCF    07.4
0173:  BCF    22.4
0174:  MOVF   22,W
0175:  BSF    03.5
0176:  MOVWF  07
0177:  MOVLW  04
0178:  MOVWF  77
0179:  DECFSZ 77,F
017A:  GOTO   179
017B:  BCF    03.5
017C:  BCF    07.3
017D:  BCF    22.3
017E:  MOVF   22,W
017F:  BSF    03.5
0180:  MOVWF  07
....................       i2c_write(EEPROM_ADRESS_READ);     //Agora como leitura 
0181:  MOVLW  A1
0182:  BCF    03.5
0183:  MOVWF  25
0184:  CALL   013
....................       saida = i2c_read(0);       //Lê o valor do bus I2C e mostra o valor nos leds 
0185:  CLRF   77
0186:  GOTO   073
0187:  MOVF   78,W
0188:  MOVWF  08
....................       i2c_stop();                //Finaliza a comunicação com o barramento 
0189:  BCF    22.4
018A:  MOVF   22,W
018B:  BSF    03.5
018C:  MOVWF  07
018D:  NOP
018E:  BCF    03.5
018F:  BSF    22.3
0190:  MOVF   22,W
0191:  BSF    03.5
0192:  MOVWF  07
0193:  BCF    03.5
0194:  BTFSS  07.3
0195:  GOTO   194
0196:  MOVLW  04
0197:  MOVWF  77
0198:  DECFSZ 77,F
0199:  GOTO   198
019A:  GOTO   19B
019B:  NOP
019C:  BSF    22.4
019D:  MOVF   22,W
019E:  BSF    03.5
019F:  MOVWF  07
01A0:  MOVLW  04
01A1:  MOVWF  77
01A2:  DECFSZ 77,F
01A3:  GOTO   1A2
....................        
....................       } 
01A4:  BCF    03.5
01A5:  GOTO   0EB
.................... //********************************* FIM ************************************** 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
01A6:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT NOPROTECT BROWNOUT NOLVP NOCPD NOWRT NODEBUG
